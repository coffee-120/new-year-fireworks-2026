<!doctype html>
<html lang="zh-CN">
  <head>
    <!-- 
      2026 Fireworks - 新年烟花特效
      项目代码部分为原创开发，遵循MIT许可证
      
      重要版权声明：
      audio/目录下的音频文件来自网络资源，版权归原作者所有
      音频文件仅用于非商业的学习和演示目的
      建议在实际部署时替换为拥有合法授权的音频文件
    -->
    <meta charset="utf-8" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>2026 Fireworks</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: "Comic Sans MS", "PingFang SC", "Microsoft YaHei", system-ui, -apple-system, Segoe UI,
          Roboto, Helvetica, Arial, sans-serif;
      }
      #app {
        position: fixed;
        inset: 0;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      .hint {
        position: fixed;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
        color: rgba(255, 255, 255, 0.72);
        font-size: 22px;
        letter-spacing: 0.2px;
        user-select: none;
        pointer-events: none;
        text-shadow: 0 0 14px rgba(0, 0, 0, 0.55);
        z-index: 10000;
      }
      .hint b {
        color: rgba(255, 255, 255, 0.9);
        font-weight: 700;
      }
      #debug {
        position: fixed;
        right: 10px;
        bottom: 10px;
        z-index: 10;
        color: rgba(255, 255, 255, 0.85);
        font-size: 8px;
        line-height: 1.35;
        white-space: pre;
        user-select: none;
        pointer-events: none;
        padding: 6px 7px;
        border-radius: 8px;
        background: transparent;
        box-shadow: none;
        backdrop-filter: none;
      }
      #longTextContainer {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: rgba(255, 255, 255, 0.95);
        text-align: center;
        z-index: 20000;
        pointer-events: none;
        display: none;
        font-family: "SimSun", "Songti SC", "PingFang SC", "Microsoft YaHei", sans-serif;
        font-weight: 400;
        font-size: 18px; /* Approx 四号 */
        line-height: 2.0; /* Increased line spacing */
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        white-space: pre-wrap;
        width: 90%;
        max-width: 800px;
      }
      .long-text-line {
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 1.0s ease-out, transform 1.0s ease-out;
      }
      .long-text-line.visible {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div id="longTextContainer"></div>
    <div class="hint">点击开启2026</div>
    <div id="debug" style="display: none"></div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
      (() => {
        const BUILD_ID = "build-2026-01-16-213";
        try {
          document.title = `2026 Fireworks (${BUILD_ID})`;
        } catch {}

        const CONFIG = {
          friendName: "My Friend",
          negativeWords: [
            "焦虑",
            "内耗",
            "加班",
            "压力",
            "失眠",
            "赶工",
            "KPI",
            "摆烂",
            "焦灼",
            "emo",
            "痛苦",
            "拖延",
            "崩溃",
            "迷茫",
            "自责",
            "倦怠",
            "疲惫",
            "透支",
            "熬夜",
            "躺平",
            "社恐",
            "自我怀疑",
            "玻璃心",
            "缺乏动力",
            "注意力涣散",
            "情绪低落",
            "精神内耗",
            "低效率",
            "焦躁",
            "烦闷",
            "烦躁",
            "无力感",
            "空虚",
            "孤独",
            "不安",
            "恐惧",
            "紧绷",
            "负面循环",
            "摆不烂",
            "卷不动",
            "心累",
            "脑雾",
            "自我否定",
            "拖到最后",
            "强迫症",
            "社交疲劳",
            "消息轰炸",
            "被催促",
            "deadline",
            "绩效焦虑",
            "通勤地狱",
            "信息过载",
            "情绪波动",
            "失控感",
            "低电量",
            "疲于奔命",
            "越想越乱",
            "越做越慢",
          ],
          debug: {
            enabled: true,
            overlay: true, // 在屏幕上显示调试信息
            logEverySeconds: 1.5,
            autoStart: false,
          },
          finaleText: {
            lines: ["诸位", "2026 新年快乐"],
            lineGap: 5.5,
          },
          maxParticles: 42000,
          fireworks: {
            rocketsPerSecond: 3.2,
            rocketBurstMin: 260,
            rocketBurstMax: 520,
            speedScale: 0.4,
            gravity: 5.2,
            friction: 0.985,
            biasX: 3.8,
            biasY: -2.1,
            biasZ: 0.0,
          },
          visuals: {
            dprMax: 1.75,
            trails: {
              width: 0.102,
              widthExplosion: 0.078,
              rocketLength: 5.805,
              sparkLength: 8.4,
              explosionLength: 0.36,
            },
            bloom: {
              strength: 0.85,  // 减弱爆炸光强度
              radius: 0.68,
              threshold: 0.22,
            },
          },
          stage: {
            countdownSeconds: 5,
            fireworksSeconds: 23,
            finaleSeconds: 14,
          },
          sounds: {
            enabled: true,
          },
        };

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const rand = (a, b) => a + Math.random() * (b - a);
        const randInt = (a, b) => (a + Math.floor(Math.random() * (b - a + 1))) | 0;

        const app = document.getElementById("app");
        const debugEl = document.getElementById("debug");
        const urlParams = new URLSearchParams(location.search);
        if (urlParams.get("debug") === "0") CONFIG.debug.enabled = false;
        if (urlParams.get("overlay") === "0") CONFIG.debug.overlay = false;
        if (urlParams.get("autostart") === "1") CONFIG.debug.autoStart = true;

        const DEBUG = {
          enabled: !!CONFIG.debug.enabled,
          overlay: !!CONFIG.debug.overlay,
          lastOverlayAt: 0,
          lastLogAt: 0,
          lastError: "",
          
          log(...args) {
            return;
          },
          warn(...args) {
            console.warn("[fw]", ...args);
          },
          error(...args) {
            console.error("[fw]", ...args);
          },
          setError(msg) {
            this.lastError = String(msg || "");
          },
          overlayText(text) {
            // 如果启用了覆盖显示，强制显示调试信息
            if (!this.overlay || !debugEl) return;
            debugEl.style.display = "block";
            // 确保显示在最顶层
            debugEl.style.zIndex = "99999";
            debugEl.style.color = "#00ff00"; // 亮绿色
            debugEl.style.textShadow = "1px 1px 1px #000";
            debugEl.textContent = text;
          },
        };
        
        const soundManager = {
          _activeSounds: 0,
          _pools: {},
          _loops: {},
          _loopId: 0,
          _mix: {
            fireworks: 1.0,
            bgm: 0.64,
            voice: 0.75,
          },
          _throttle: {
            active: false,
            climaxAudio: null,
            climaxVolume: 0,
          },
          _bgm: {
            key: "things",
            audio: null,
            started: false,
            pausedByInterruption: false,
            pausedAt: 0,
            volume: 0.64,
          },
          
          sounds: {
            launch: "audio/launch.m4a",
            firstl: "audio/firstl.m4a", // 第一个烟花发射音效
            singal: "audio/singal.m4a", // 小爆炸声
            giant: "audio/giant_boom.m4a", // 大爆炸声
            secondary: "audio/secondary_explosion.m4a", // 噼啪声
            climax: "audio/climax.m4a", // 环境音效
            // 倒计时音效
            c5: "audio/5.m4a",
            c4: "audio/4.m4a",
            c3: "audio/3.m4a",
            c2: "audio/2.m4a",
            c1: "audio/1.m4a",
            // 开场音效
            hey: "audio/hey.m4a",
            happyny: "audio/happyny.m4a",
            things: "audio/things_you_said.m4a",
            // 用户自定义音效
            sun: "audio/sun.m4a",
            tim: "audio/tim.m4a",
            silence: "audio/silence.m4a",
          },

          init() {
            try {
              const raw = localStorage.getItem("fw_mix_v2");
              if (raw) {
                const v = JSON.parse(raw);
                if (v && typeof v === "object") {
                  if (Number.isFinite(v.fireworks)) this._mix.fireworks = clamp(v.fireworks, 0, 1);
                  if (Number.isFinite(v.bgm)) this._mix.bgm = clamp(v.bgm, 0, 1);
                  if (Number.isFinite(v.voice)) this._mix.voice = clamp(v.voice, 0, 1);
                }
              }
            } catch {}
            this._bgm.volume = clamp(this._mix.bgm, 0, 1);
            Object.keys(this.sounds).forEach(key => {
              this._pools[key] = [];
            });
          },
          
          _saveMix() {
            try {
              localStorage.setItem("fw_mix_v2", JSON.stringify(this._mix));
            } catch {}
          },

          setMixVolumes(next) {
            if (!next || typeof next !== "object") return;
            if (Number.isFinite(next.fireworks)) this._mix.fireworks = clamp(next.fireworks, 0, 1);
            if (Number.isFinite(next.bgm)) this._mix.bgm = clamp(next.bgm, 0, 1);
            if (Number.isFinite(next.voice)) this._mix.voice = clamp(next.voice, 0, 1);
            this._bgm.volume = this._mix.bgm;
            const bgmAudio = this._bgm && this._bgm.audio ? this._bgm.audio : null;
            if (bgmAudio) {
              const base = Number.isFinite(bgmAudio._baseVolume) ? bgmAudio._baseVolume : 1.0;
              try { bgmAudio.volume = clamp(base * this._mix.bgm, 0, 1); } catch {}
            }
            Object.keys(this._pools || {}).forEach((k) => {
              const pool = this._pools[k];
              if (!pool) return;
              for (let i = 0; i < pool.length; i++) {
                const a = pool[i];
                if (!a || !a._busy) continue;
                const base = Number.isFinite(a._baseVolume) ? a._baseVolume : a.volume;
                const g = this._soundGroup(a._key || k);
                const mul = this._mix[g] == null ? 1.0 : this._mix[g];
                try { a.volume = clamp(base * mul, 0, 1); } catch {}
              }
            });
            this._saveMix();
          },

          _soundGroup(key) {
            if (key === "things") return "bgm";
            if (key === "sun" || key === "tim" || key === "silence") return "voice";
            if (key === "hey" || key === "happyny") return "voice";
            return "fireworks";
          },

          _fadeAudioVolume(a, toVolume, durationMs, onDone) {
            if (!a) return;
            if (a._fadeRaf) {
              try { cancelAnimationFrame(a._fadeRaf); } catch {}
              a._fadeRaf = 0;
            }
            const from = (() => {
              try { return a.volume; } catch { return 0; }
            })();
            const to = clamp(toVolume, 0, 1);
            const dur = Math.max(0, durationMs | 0);
            const start = nowMs();
            const token = (a._fadeToken || 0) + 1;
            a._fadeToken = token;
            const step = () => {
              if (!a || a._fadeToken !== token) return;
              const t = nowMs() - start;
              const k = dur <= 0 ? 1 : clamp(t / dur, 0, 1);
              const kk = 1 - Math.pow(1 - k, 3);
              const v = from + (to - from) * kk;
              try { a.volume = clamp(v, 0, 1); } catch {}
              if (k < 1) {
                a._fadeRaf = requestAnimationFrame(step);
              } else {
                a._fadeRaf = 0;
                if (typeof onDone === "function") onDone();
              }
            };
            a._fadeRaf = requestAnimationFrame(step);
          },

          _createAudio(key) {
            const src = this.sounds[key];
            if (!src) return null;
            const a = new Audio(src);
            a.preload = "auto";
            a._key = key;
            const onDone = () => {
              a._busy = false;
              if (a._stopTimer) { clearTimeout(a._stopTimer); a._stopTimer = null; }
            };
            a.onended = onDone;
            a.onerror = onDone;
            this._pools[key].push(a);
            return a;
          },

          _getAudio(key) {
            const pool = this._pools[key];
            if (!pool) return null;
            for (let i = 0; i < pool.length; i++) {
              if (!pool[i]._busy) return pool[i];
            }
            if (pool.length < 24) return this._createAudio(key);
            return null;
          },

          startThingsBgm() {
            const bgm = this._bgm;
            if (!bgm || bgm.started) return;
            const a = this._createAudio(bgm.key) || this._getAudio(bgm.key);
            if (!a) return;
            bgm.audio = a;
            bgm.started = true;
            bgm.pausedByInterruption = false;
            bgm.pausedAt = 0;
            try {
              a.loop = true;
              a.currentTime = 0;
              a._baseVolume = 1.0;
              a.volume = clamp(this._mix.bgm, 0, 1);
              a.playbackRate = 1.0;
              a._busy = true;
              const p = a.play();
              if (p && p.catch) p.catch(() => {});
            } catch {}
          },

          pauseThingsBgmForInterruption() {
            const bgm = this._bgm;
            const a = bgm && bgm.audio ? bgm.audio : null;
            if (!a || a.paused) return;
            try {
              bgm.pausedAt = a.currentTime || 0;
            } catch {
              bgm.pausedAt = 0;
            }
            this._fadeAudioVolume(a, 0, 260, () => {
              try { a.pause(); } catch {}
            });
            bgm.pausedByInterruption = true;
          },

          resumeThingsBgmAfterInterruption() {
            const bgm = this._bgm;
            const a = bgm && bgm.audio ? bgm.audio : null;
            if (!a || !bgm.pausedByInterruption) return;
            try {
              if (Number.isFinite(bgm.pausedAt) && bgm.pausedAt > 0) a.currentTime = bgm.pausedAt;
            } catch {}
            try {
              a._baseVolume = 1.0;
              a.volume = 0;
              a._busy = true;
              const p = a.play();
              if (p && p.catch) p.catch(() => {});
            } catch {}
            this._fadeAudioVolume(a, clamp(this._mix.bgm, 0, 1), 380, null);
            bgm.pausedByInterruption = false;
          },

          // 参数选项: { pitch, volume, delay(ms), duration(s), force(bool) }
          // 辅助函数: 解析SRT字幕格式
          // 示例格式:
          // 1
          // 00:00:01,000 --> 00:00:04,000
          // 你好世界
          parseSRT(srtContent) {
             const items = [];
             // 修复: 处理CRLF和LF换行符
             const safe = String(srtContent || "").replace(/^\uFEFF/, "");
             const blocks = safe.trim().replace(/\r\n/g, '\n').split(/\n\s*\n/);
             blocks.forEach(block => {
                 const lines = block.split('\n');
                 if (lines.length >= 3) {
                     // 第0行: 字幕ID
                     // 第1行: 时间码
                     const timeMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})[,.](\d{3})/);
                     if (timeMatch) {
                         const startS = parseInt(timeMatch[1])*3600 + parseInt(timeMatch[2])*60 + parseInt(timeMatch[3]) + parseInt(timeMatch[4])/1000;
                         const endS = parseInt(timeMatch[5])*3600 + parseInt(timeMatch[6])*60 + parseInt(timeMatch[7]) + parseInt(timeMatch[8])/1000;
                         // 处理多行文本（例如双语字幕）
                         const text = lines.slice(2).join('\n'); 
                         items.push({ time: startS, text: text, duration: endS - startS });
                     }
                 }
             });
             return items;
          },

          // 辅助函数: 播放音频并加载SRT字幕文件（通过URL获取）
          // 样式配置: { bottom: '10%', fontSize: '24px', ... }
          playAudioWithSrtFile(audioKey, srtUrl, styleConfig = {}) {
              fetch(srtUrl)
                .then(res => res.text())
                .then(text => {
                    const subtitles = this.parseSRT(text);
                    this.playAudioWithSubtitles(audioKey, subtitles, styleConfig);
                })
                .catch(err => console.error("Failed to load subtitle file:", err));
          },

          // 音频同步功能
          // 调用此函数播放音频并同步显示字幕
          // 字幕格式: [{ time: 0.5, text: "你好" }, { time: 2.0, text: "世界" }]
          playAudioWithSubtitles(audioKey, subtitles, styleConfig = {}) {
             const audio = this.play(audioKey, { force: true });
             if (!audio) return;
             this._subtitleOwnerKey = audioKey;
             const rawFontSize = styleConfig.fontSize ?? '24px';
             let baseFontPx = typeof rawFontSize === 'number' ? rawFontSize : parseFloat(String(rawFontSize));
             if (!Number.isFinite(baseFontPx) || baseFontPx <= 0) baseFontPx = 24;
             const fontSizeCss = `${baseFontPx * 0.5}px`;
             
             // 清除现有的同步定时器
             if (this._syncTimers) {
                 this._syncTimers.forEach(t => clearTimeout(t));
             }
             this._syncTimers = [];
             if (this._syncHideTimers) {
                 this._syncHideTimers.forEach(t => clearTimeout(t));
             }
             this._syncHideTimers = [];
             
             // 如果字幕容器不存在则创建
             let subContainer = document.getElementById('subtitle-container');
             if (!subContainer) {
                 subContainer = document.createElement('div');
                 subContainer.id = 'subtitle-container';
                 subContainer.style.position = 'absolute';
                 subContainer.style.bottom = styleConfig.bottom || '15%'; // 底部位置
                 subContainer.style.left = '50%';
                 subContainer.style.transform = 'translateX(-50%)';
                 subContainer.style.textAlign = 'center';
                 subContainer.style.pointerEvents = 'none';
                 subContainer.style.zIndex = '25000';
                 subContainer.style.width = '100%';
                 subContainer.style.display = 'none'; // 默认隐藏
                 document.body.appendChild(subContainer);
             }
             subContainer.style.display = 'none';
             subContainer.innerHTML = '';

             const cleanup = () => {
                 if (this._syncTimers) this._syncTimers.forEach(t => clearTimeout(t));
                 if (this._syncHideTimers) this._syncHideTimers.forEach(t => clearTimeout(t));
                 this._syncTimers = [];
                 this._syncHideTimers = [];
                 subContainer.style.display = 'none';
                 subContainer.innerHTML = '';
                 if (this._subtitleOwnerKey === audioKey) this._subtitleOwnerKey = null;
             };

             audio.addEventListener('ended', cleanup, { once: true });
             audio.addEventListener('error', cleanup, { once: true });
             
             subtitles.forEach(item => {
                 const delay = item.time * 1000;
                 const timer = setTimeout(() => {
                     // 触发DOM字幕显示
                     subContainer.style.display = 'block';
                     
                     // 格式化文本: 将换行符替换为<br>以支持双语显示
                     // 支持SRT中的简单HTML
                     const htmlText = item.text.replace(/\n/g, '<br/>');
                     
                     subContainer.innerHTML = `
                        <div style="
                            font-family: 'Microsoft YaHei', sans-serif; 
                            text-shadow: 0 2px 4px rgba(0,0,0,0.8); 
                            color: #ffffff; 
                            font-size: ${fontSizeCss}; 
                            line-height: 1.5;
                            background: transparent;
                            padding: 10px 20px;
                            border-radius: 8px;
                            display: inline-block;
                        ">${htmlText}</div>
                     `;
                     
                     // 持续时间结束后自动隐藏
                     const hideTimer = setTimeout(() => {
                         // 仅当内容未改变时隐藏（简单检查）
                         // 实际上，下一个字幕会覆盖，所以只需检查时间或让它持续到下一个？
                         // 最好在没有立即下一个字幕时清除。
                         // 为简单起见，只需设置透明度或清空内容。
                         // 但如果清除，可能会清除重叠的下一个字幕。
                         // 我们依赖定时器已安排的事实。
                         // 但我们应该在持续时间过后隐藏。
                         // 为防止竞争条件，可以检查内容是否仍然是我们的。
                         // 简化：仅在持续时间过后隐藏。
                         // 如果下一个字幕开始，它会取消隐藏并设置新内容。
                         if (subContainer.innerHTML.includes(htmlText)) {
                            subContainer.style.display = 'none';
                         }
                     }, (item.duration || 2.0) * 1000);
                     this._syncHideTimers.push(hideTimer);
                     
                 }, delay);
                 this._syncTimers.push(timer);
             });
             return audio;
          },

          play(key, options = {}) {
            if (!CONFIG.sounds || CONFIG.sounds.enabled === false) return;
            
            if (stageState.stage === 4 && stageState._aliveCount > 15000) {
                if (
                  key === 'launch' ||
                  key === 'firstl' ||
                  key === 'singal' ||
                  key === 'giant' ||
                  key === 'secondary' ||
                  key === 'c1' ||
                  key === 'c2' ||
                  key === 'c3' ||
                  key === 'c4' ||
                  key === 'c5'
                ) {
                  return null;
                }
            }

            const { pitch = 1.0, volume = 1.0, delay = 0, duration = 0 } = options;

            if (delay > 0) {
              setTimeout(() => this.play(key, { ...options, delay: 0 }), delay);
              return null;
            }

            if (key === "hey") {
              this.pauseThingsBgmForInterruption();
            }

            const a = this._getAudio(key);
            if (!a) return null;

            a._busy = true;
            try {
              a.currentTime = 0;
              const baseVol = clamp(volume, 0, 1);
              const g = this._soundGroup(key);
              const mul = this._mix[g] == null ? 1.0 : this._mix[g];
              a._baseVolume = baseVol;
              a.volume = clamp(baseVol * mul, 0, 1);
              a.playbackRate = clamp(pitch, 0.5, 4.0);
            } catch(e) {}

            if (key === "happyny") {
              const onDone = () => this.resumeThingsBgmAfterInterruption();
              try {
                a.addEventListener("ended", onDone, { once: true });
                a.addEventListener("error", onDone, { once: true });
              } catch {}
            }
            
            // 处理持续时间截断
            if (a._stopTimer) { clearTimeout(a._stopTimer); a._stopTimer = null; }
            if (duration > 0) {
               a._stopTimer = setTimeout(() => {
                  try { a.pause(); } catch{}
                  a._busy = false;
               }, duration * 1000);
            }

            this._activeSounds++;
            const p = a.play();
            if (p && p.catch) {
               p.catch(() => {
                  a._busy = false;
               });
            }
            return a;
          },

          startLoop(type, interval = 100) {
             const id = ++this._loopId;
             const loopObj = {
                active: true,
                type: type,
                timer: null,
                next: () => {
                   if (!loopObj.active) return;
                   // 播放带有轻微变化的音效
                   this.play(type, { 
                      volume: 0.4 + Math.random() * 0.3, 
                      pitch: 0.9 + Math.random() * 0.2 
                   });
                   // 安排下一次播放
                   loopObj.timer = setTimeout(loopObj.next, interval + Math.random() * (interval * 0.5));
                }
             };
             this._loops[id] = loopObj;
             loopObj.next();
             return id;
          },

          stopLoop(id) {
             if (this._loops[id]) {
                this._loops[id].active = false;
                if (this._loops[id].timer) clearTimeout(this._loops[id].timer);
                delete this._loops[id];
             }
          },

          update(dt, particleCount) {
             // 淡入淡出高潮音频
             const isNormalStage = stageState.stage === 4; // 阶段4是普通烟花
             const isSuperStage = stageState.stage === 7; // 阶段7是超级巨型烟花(G1-G6)
             
             // 触发逻辑: 
             // 1. 必须是普通阶段（阶段4）
             // 2. 粒子数量 > 15000
             const shouldPlay = isNormalStage && particleCount > 15000;
             const shouldStop = !isNormalStage || particleCount < 15000; // 简化逻辑，使用淡入淡出实现平滑过渡
             
             if (shouldPlay) {
                if (!this._climaxOnlyEnforced) {
                   this._climaxOnlyEnforced = true;
                   Object.keys(this._loops || {}).forEach((id) => this.stopLoop(id));
                   Object.keys(this._pools || {}).forEach((poolKey) => {
                      if (
                        poolKey === 'climax' ||
                        poolKey === 'sun' ||
                        poolKey === 'tim' ||
                        poolKey === 'silence' ||
                        poolKey === 'hey' ||
                        poolKey === 'happyny' ||
                        poolKey === 'things'
                      ) {
                        return;
                      }
                      const pool = this._pools[poolKey] || [];
                      for (let i = 0; i < pool.length; i++) {
                         const a = pool[i];
                         try { a.pause(); } catch {}
                         try { a.currentTime = 0; } catch {}
                         a._busy = false;
                      }
                   });
                   if (this._subtitleOwnerKey !== 'sun' && this._subtitleOwnerKey !== 'tim' && this._subtitleOwnerKey !== 'silence') {
                      if (this._syncTimers) this._syncTimers.forEach((t) => clearTimeout(t));
                      if (this._syncHideTimers) this._syncHideTimers.forEach((t) => clearTimeout(t));
                      this._syncTimers = [];
                      this._syncHideTimers = [];
                      const subContainer = document.getElementById('subtitle-container');
                      if (subContainer) {
                         subContainer.style.display = 'none';
                         subContainer.innerHTML = '';
                      }
                      this._subtitleOwnerKey = null;
                   }
                }
             } else {
                this._climaxOnlyEnforced = false;
             }

             if (shouldPlay) {
                if (!this._throttle.climaxAudio || this._throttle.climaxAudio.paused) {
                   const a = this._getAudio('climax');
                   if (a) {
                      this._throttle.climaxAudio = a;
                      a.loop = true;
                      a.volume = 0; // 从0开始淡入
                      a.play().catch(() => {});
                      a._busy = true; 
                   }
                }
             }

             // 处理音量淡入淡出
             if (this._throttle.climaxAudio) {
                const a = this._throttle.climaxAudio;
                const fadeSpeed = 0.5 * dt; // 约2秒完成淡入淡出
                
                if (shouldPlay) {
                   // 淡入
                  a.volume = Math.min(clamp(this._mix.fireworks, 0, 1), a.volume + fadeSpeed);
                } else {
                   // 淡出
                   a.volume = Math.max(0, a.volume - fadeSpeed);
                   if (a.volume <= 0.01) {
                      a.pause();
                      a.currentTime = 0;
                      a._busy = false;
                      this._throttle.climaxAudio = null;
                   }
                }
             }
          }
        };
        soundManager.init();

        const rootScaleEl = document.body;
        if (rootScaleEl) {
          rootScaleEl.style.transformOrigin = "50% 50%";
          rootScaleEl.style.willChange = "transform";
          rootScaleEl.style.transform = "scale(1)";
          rootScaleEl.style.transition = "transform 780ms cubic-bezier(0.2, 0.8, 0.2, 1)";
        }
        const setRootScale = (scale) => {
          if (!rootScaleEl) return;
          const s = Math.max(0.01, +scale || 1);
          rootScaleEl.style.transform = `scale(${s})`;
        };

        window.addEventListener("error", (e) => {
          DEBUG.setError(e && e.message ? e.message : "window.error");
          DEBUG.error("window.error", e && e.message, e && e.filename, e && e.lineno, e && e.colno);
        });
        window.addEventListener("unhandledrejection", (e) => {
          DEBUG.setError(e && e.reason ? e.reason : "unhandledrejection");
          DEBUG.error("unhandledrejection", e && e.reason);
        });

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setClearColor(0x000000, 1);
        renderer.setPixelRatio(Math.min(CONFIG.visuals.dprMax, window.devicePixelRatio || 1));
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.15;
        renderer.domElement.addEventListener(
          "webglcontextlost",
          (e) => {
            e.preventDefault();
            DEBUG.setError("webglcontextlost");
            DEBUG.error("webglcontextlost");
          },
          false
        );
        renderer.domElement.addEventListener(
          "webglcontextrestored",
          () => {
            DEBUG.setError("");
            DEBUG.warn("webglcontextrestored");
          },
          false
        );
        app.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012);

        const starfield = (() => {
          const starCount = 2000;
          const positions = new Float32Array(starCount * 3);
          const colors = new Float32Array(starCount * 3);
          for (let i = 0; i < starCount; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta = u * Math.PI * 2;
            const phi = Math.acos(2 * v - 1);
            const r = rand(26, 92);
            const x = Math.cos(theta) * Math.sin(phi) * r;
            const y = Math.cos(phi) * r + rand(-8, 10);
            const z = Math.sin(theta) * Math.sin(phi) * r - 18;
            positions[i * 3 + 0] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            const tint = rand(0.0, 1.0);
            const warm = new THREE.Color().setHSL(rand(0.08, 0.14), rand(0.25, 0.6), rand(0.55, 0.78));
            const cool = new THREE.Color().setHSL(rand(0.55, 0.62), rand(0.25, 0.55), rand(0.55, 0.78));
            const c = cool.lerp(warm, tint);
            colors[i * 3 + 0] = c.r;
            colors[i * 3 + 1] = c.g;
            colors[i * 3 + 2] = c.b;
          }

          const canvas = document.createElement("canvas");
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext("2d");
          const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
          grd.addColorStop(0.0, "rgba(255,255,255,1)");
          grd.addColorStop(0.12, "rgba(255,255,255,0.85)");
          grd.addColorStop(0.32, "rgba(255,255,255,0.28)");
          grd.addColorStop(1.0, "rgba(255,255,255,0)");
          ctx.clearRect(0, 0, 64, 64);
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
          const tex = new THREE.CanvasTexture(canvas);
          tex.encoding = THREE.sRGBEncoding;
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;

          const g = new THREE.BufferGeometry();
          g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          g.setAttribute("color", new THREE.BufferAttribute(colors, 3));

          const m = new THREE.PointsMaterial({
            map: tex,
            vertexColors: true,
            size: 0.72,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.22,
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
          });

          const stars = new THREE.Points(g, m);
          stars.frustumCulled = false;
          const group = new THREE.Group();
          group.add(stars);
          scene.add(group);
          return { group, stars };
        })();

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
        // 初始相机位置调整：仰视视角 (Y轴降低，Z轴拉远)
        camera.position.set(0, 0.5, 16.0);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.enablePan = false;
        controls.enableZoom = true;
        controls.minDistance = 6.0;
        controls.maxDistance = 80.0;
        controls.rotateSpeed = 0.35;
        controls.minPolarAngle = 0.45;
        controls.maxPolarAngle = 1.3;
        // 目标点上调至屏幕中心 (y=2.0)，配合相机位置形成仰视
        controls.target.set(0, 2.0, 0);

        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          CONFIG.visuals.bloom.strength,
          CONFIG.visuals.bloom.radius,
          CONFIG.visuals.bloom.threshold
        );
        composer.addPass(bloomPass);

        const clock = new THREE.Clock();

        const neonPalette = [
          // 2026 高级拟真烟花配色：金属质感 + 稀有化学色
          new THREE.Color("#FFD700"), // 鎏金 (Gold) - 奢华
          new THREE.Color("#FF4500"), // 炽红 (OrangeRed) - 激情
          new THREE.Color("#00BFFF"), // 铜蓝 (Deep Sky Blue) - 深邃
          new THREE.Color("#FF1493"), // 玫红 (Deep Pink) - 典雅
          new THREE.Color("#32CD32"), // 焰绿 (Lime Green) - 生机
          new THREE.Color("#9400D3"), // 紫罗兰 (Dark Violet) - 神秘
          new THREE.Color("#00FA9A"), // 青鸾 (Medium Spring Green) - 灵动
          new THREE.Color("#F0F8FF"), // 银白 (Alice Blue) - 纯净闪烁
          new THREE.Color("#FFDAB9"), // 香槟 (Peach Puff) - 温柔
          new THREE.Color("#00FFFF"), // 电光蓝 (Cyan) - 科技感
        ];

        function pickNeonColor() {
          // 选取基准色
          const base = neonPalette[(Math.random() * neonPalette.length) | 0];
          const c = base.clone();
          
          const hsl = { h: 0, s: 0, l: 0 };
          c.getHSL(hsl);
          
          // 极微小的色相偏移，保持色彩纯正度
          hsl.h += (Math.random() - 0.5) * 0.03;
          if (hsl.h < 0) hsl.h += 1;
          if (hsl.h > 1) hsl.h -= 1;
          
          // 饱和度：保持极高 (0.9-1.0)，去除"塑料感"的关键是避免灰暗的中间调
          hsl.s = clamp(hsl.s + (Math.random() - 0.5) * 0.1, 0.9, 1.0);
          
          // 亮度：提升亮度上限 (0.6-0.95)，模拟燃烧的高温白炽感，增加"震撼"效果
          hsl.l = clamp(hsl.l + (Math.random() - 0.5) * 0.25, 0.6, 0.95);
          
          c.setHSL(hsl.h, hsl.s, hsl.l);
          return c;
        }

        function createTextSprite(text, options) {
          const opt = Object.assign(
            {
              fontSize: 54,
              fontFamily: '"Comic Sans MS","PingFang SC","Microsoft YaHei",sans-serif',
              paddingX: 22,
              paddingY: 16,
              color: "rgba(255,255,255,0.92)",
              stroke: "rgba(0,0,0,0.65)",
              bg: "rgba(0,0,0,0.0)",
              shadow: "rgba(0,0,0,0.55)",
            },
            options || {}
          );
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          ctx.font = `${opt.fontSize}px ${opt.fontFamily}`;
          const metrics = ctx.measureText(text);
          const w = Math.ceil(metrics.width + opt.paddingX * 2);
          const h = Math.ceil(opt.fontSize + opt.paddingY * 2);
          canvas.width = w;
          canvas.height = h;
          ctx.clearRect(0, 0, w, h);
          ctx.font = `${opt.fontSize}px ${opt.fontFamily}`;
          ctx.textBaseline = "middle";
          ctx.textAlign = "center";
          if (opt.bg && opt.bg !== "rgba(0,0,0,0.0)") {
            ctx.fillStyle = opt.bg;
            ctx.fillRect(0, 0, w, h);
          }
          ctx.shadowColor = opt.shadow;
          ctx.shadowBlur = 14;
          ctx.lineWidth = 10;
          ctx.strokeStyle = opt.stroke;
          ctx.strokeText(text, w * 0.5, h * 0.55);
          ctx.shadowBlur = 0;
          ctx.fillStyle = opt.color;
          ctx.fillText(text, w * 0.5, h * 0.55);
          const texture = new THREE.CanvasTexture(canvas);
          texture.encoding = THREE.sRGBEncoding;
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = false;
          const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 1, depthWrite: false });
          material.blending = THREE.AdditiveBlending;
          const sprite = new THREE.Sprite(material);
          const scale = opt.scale || 1;
          sprite.scale.set((w / 240) * scale, (h / 240) * scale, 1);
          sprite.userData._bounds = { w: sprite.scale.x, h: sprite.scale.y };
          return sprite;
        }

        const wordGroup = new THREE.Group();
        scene.add(wordGroup);

        const wordState = {
          sprites: [],
          pos: [],
          vel: [],
          rot: [],
          ang: [],
          alpha: [],
          alive: [],
          mode: [],
          seed1: [],
          seed2: [],
          blastAge: [],
          blastOutAge: [],
          blastLife: [],
          blastCenter: new THREE.Vector3(0, 2.2, 0),
          blastActive: 0,
          blastT: 0,
          dimTarget: 1,
        };

        function initNegativeWords() {
          const words = Array.from(
            new Set(
              (CONFIG.negativeWords || [])
                .map((s) => String(s || "").trim())
                .filter((s) => s.length > 0)
            )
          );
          // 确保有足够的词汇填充8个区域，每个区域5个词，共40个词
          // 如果词汇数组较小，则重复使用
          const totalWords = 40; 
          const fallback = [
            "过度思考",
            "过度担心",
            "精神紧张",
            "情绪崩盘",
            "自我拉扯",
            "无休止加班",
            "疲劳驾驶",
            "情绪内伤",
            "精力透支",
            "心态爆炸",
          ];
          for (let i = 0; i < fallback.length && words.length < totalWords; i++) {
            const w = String(fallback[i] || "").trim();
            if (w && !words.includes(w)) words.push(w);
          }
          for (let i = words.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0;
            const tmp = words[i];
            words[i] = words[j];
            words[j] = tmp;
          }
          const pick = words.slice(0, totalWords);
          const sprites = [];
          const pos = [];
          const vel = [];
          const rot = [];
          const ang = [];
          const alpha = [];
          const alive = [];
          const mode = [];
          const seed1 = [];
          const seed2 = [];
          const blastAge = [];
          const blastOutAge = [];
          const blastLife = [];
          const regionInfo = []; // 存储每个词汇的区域边界
          
          const aspect = window.innerWidth / window.innerHeight;
          const visibleH = 14.0; 
          const visibleW = visibleH * aspect;
          
          // 1. Divide visible window into 8 parts (4 columns x 2 rows)
          const cols = 4;
          const rows = 2;
          const cellW = visibleW / cols;
          const cellH = visibleH / rows;
          
          for (let i = 0; i < totalWords; i++) {
            const t = pick[i] || "";
            const s = createTextSprite(t, {
              fontSize: randInt(56, 88),
              color: "rgba(255,255,255,0.9)",
              stroke: "rgba(0,0,0,0.65)",
              shadow: "rgba(0,0,0,0.55)",
              scale: rand(1.15, 1.65),
            });
            
            // 分配到区域：每个区域5个词汇
            // 区域索引 0..7
            const regionIdx = Math.floor(i / 5); 
            
            const cellX = regionIdx % cols;
            const cellY = Math.floor(regionIdx / cols);
            
            // 计算区域边界（世界空间）
            // X: 从左到右
            // Y: 从上到下（第0行是顶部，第1行是底部）
            // 相机Y通常位于2.2
            // 与updateWords逻辑对齐
            
            const baseX = (cellX - cols/2 + 0.5) * cellW;
            // 第0行是顶部，第1行是底部
            // 如果cellY=0 -> 顶部，如果cellY=1 -> 底部
            const baseY = (-(cellY - rows/2 + 0.5)) * cellH + 2.2; 
            
            const regionBounds = {
               minX: baseX - cellW * 0.45,
               maxX: baseX + cellW * 0.45,
               minY: baseY - cellH * 0.45,
               maxY: baseY + cellH * 0.45,
               minZ: -4.0,
               maxZ: 2.0
            };
            
            const x = rand(regionBounds.minX, regionBounds.maxX);
            const y = rand(regionBounds.minY, regionBounds.maxY);
            const z = rand(regionBounds.minZ, regionBounds.maxZ);
            
            s.position.set(x, y, z);
            s.renderOrder = 5;
            s.userData._id = i;
            s.userData._r = 0.5 * Math.max(s.userData._bounds.w, s.userData._bounds.h);
            s.userData._region = regionBounds; // 存储边界信息
            
            sprites.push(s);
            pos.push(s.position);
            vel.push(new THREE.Vector3(rand(-0.3, 0.3), rand(-0.2, 0.2), rand(-0.2, 0.2)));
            rot.push(rand(-0.25, 0.25));
            ang.push(rand(-0.6, 0.6));
            alpha.push(1);
            alive.push(1);
            mode.push(0);
            seed1.push(rand(0, 1000));
            seed2.push(rand(0, 1000));
            blastAge.push(0);
            blastOutAge.push(0);
            blastLife.push(1);
            regionInfo.push(regionBounds);
            wordGroup.add(s);
          }
          wordState.sprites = sprites;
          wordState.pos = pos;
          wordState.vel = vel;
          wordState.rot = rot;
          wordState.ang = ang;
          wordState.alpha = alpha;
          wordState.alive = alive;
          wordState.mode = mode;
          wordState.seed1 = seed1;
          wordState.seed2 = seed2;
          wordState.blastAge = blastAge;
          wordState.blastOutAge = blastOutAge;
          wordState.blastLife = blastLife;
          wordState.regionInfo = regionInfo;
        }

        initNegativeWords();

        function updateWords(dt, stage, t) {
          const sprites = wordState.sprites;
          const vel = wordState.vel;
          const alpha = wordState.alpha;
          const alive = wordState.alive;
          const mode = wordState.mode;
          const blastAge = wordState.blastAge;
          const blastOutAge = wordState.blastOutAge;
          const blastLife = wordState.blastLife;

          wordState.dimTarget = (stage === 1 || stage === 2 || stage === 25) ? 0.15 : 1.0;

          const normalSpeedMul = 0.8;
          
          // 动态边界计算
          const fov = (camera.fov * Math.PI) / 180;
          // 词汇的近似Z深度约为0。相机位于13.5
          const dist = Math.abs(camera.position.z);
          const visibleH = 2 * Math.tan(fov / 2) * dist;
          const visibleW = visibleH * camera.aspect;
          
          // 优化边界：覆盖80%窗口空间，防止URL栏重叠
          const marginX = 0.8;  // 减少边距让词汇更接近边缘
          const marginY = 1.0;  // 减少垂直边距
          
          // 计算边界，相对相机Y中心(2.2)
          const camY = camera.position.y;
          const topY = camY + visibleH / 2 - marginY;
          // 优化底部边界：极小的padding，允许词汇覆盖到底部
          const bottomY = camY - visibleH / 2 + 1.5; 
          const rightX = visibleW / 2 - marginX;
          const leftX = -visibleW / 2 + marginX;

          const boundsNormal = { x: rightX, y: topY, z: 6.0 };
          const boundsBlast = { x: 1e9, y: 1e9, z: 1e9 };
          
          const wallE = 0.86;
          const airDragNormal = 0.576;
          const airDragBlast = 0.96;
          const maxSpeedNormal = 7.2 * normalSpeedMul;
          const maxSpeedBlast = 25.0; // 增加爆炸模式下的最大速度
          const smoothstep = (a, b, x) => {
            const t = clamp((x - a) / (b - a), 0, 1);
            return t * t * (3 - 2 * t);
          };

          const steps = Math.min(4, Math.max(1, Math.ceil(dt / 0.016)));
          const h = dt / steps;
          const doCollide = stage === 1 || stage === 2 || stage === 3;
          const e = 0.78;
          const nrm = new THREE.Vector3();
          const tmp = new THREE.Vector3();

          for (let step = 0; step < steps; step++) {
            if (wordState.blastActive) {
              wordState.blastT += h;
              if (wordState.blastT > 0.55) wordState.blastActive = 0;
            }

            for (let i = 0; i < sprites.length; i++) {
              if (!alive[i]) continue;
              const s = sprites[i];
              const v = vel[i];
              const p = s.position;
              const r = s.userData._r || 0.8;
              const bounds = mode[i] === 1 ? boundsBlast : boundsNormal;

              if (mode[i] === 1) {
                blastAge[i] += h;
                
                // 极低阻力，让词汇保持飞出
                v.multiplyScalar(Math.exp(-0.1 * h));
                
                // 计算与爆炸中心的距离
                const dx = p.x - wordState.blastCenter.x;
                const dy = p.y - wordState.blastCenter.y;
                const dz = p.z - wordState.blastCenter.z;
                const d = Math.sqrt(dx * dx + dy * dy + dz * dz) + 1e-6;
                
                // 平滑推力场：基于 blastAge 的指数衰减力
                // 模拟爆炸瞬间的冲击波，随时间快速衰减，确保轨迹平滑
                const timeFactor = Math.exp(-blastAge[i] * 3.0); // 快速衰减
                const distFactor = Math.exp(-d * 0.15); // 距离衰减
                const intensity = 120.0 * timeFactor * distFactor;
                
                // 向外推力
                const dirX = dx / d;
                const dirY = dy / d;
                const dirZ = dz / d;
                
                v.x += dirX * intensity * h;
                v.y += dirY * intensity * h;
                v.z += dirZ * intensity * h;
                
                // 添加一些随机的旋转力矩

                // 扩大边界检测范围，让词汇更容易推出屏幕
                const margin = 3.5; // 更大的缓冲
                const out =
                  p.x < -boundsNormal.x - margin ||
                  p.x > boundsNormal.x + margin ||
                  p.y < bottomY - margin - 4.5 || // 允许更低的坠落
                  p.y > boundsNormal.y + margin ||
                  p.z < -boundsNormal.z - margin ||
                  p.z > boundsNormal.z + margin;
                
                // 一旦超出边界就开始淡出计时
                blastOutAge[i] = out ? blastOutAge[i] + h : 0;
                
                // 更快的淡出效果
                const outFade = clamp(1.0 - smoothstep(0.0, 0.6, blastOutAge[i] / 0.6), 0, 1);
                alpha[i] = out ? outFade : 1;

                // 一旦淡出完成或生命周期结束，立即消失并不再返回
                if ((out && blastOutAge[i] > 0.65) || blastAge[i] > 10.0) {
                  alive[i] = 0;
                  s.visible = false;
                  continue;
                }
                
                // 移除"向外推力"逻辑，因为波浪算法已经提供了足够的推力
                // 并且我们希望它们自然飞出，不要人为干预边缘
                
              } else {
                const s1 = wordState.seed1[i] || 0;
                const s2 = wordState.seed2[i] || 0;
                
                // Use per-word region bounds if available
                const rb = s.userData._region;
                
                // 优化游走：更均匀地覆盖整个空间
                const tOff = t + s1;
                // 使用不同的频率和相位创造更自然的随机运动
                const tx = Math.sin(tOff * 0.12) + Math.sin(tOff * 0.35 + 1.2) * 0.7 + Math.cos(tOff * 0.28) * 0.3;
                const ty = Math.sin(tOff * 0.16 + 0.8) + Math.cos(tOff * 0.42 - 0.5) * 0.6 + Math.sin(tOff * 0.31) * 0.4;
                const tz = Math.cos(tOff * 0.18) + Math.sin(tOff * 0.39 + 2.1) * 0.5 + Math.cos(tOff * 0.25 - 1.7) * 0.3;
                
                let targetX, targetY, targetZ;
                
                if (rb) {
                  // Map tx, ty, tz (-2..2 approx) to region bounds
                  // Normalize t to 0..1
                  const nx = (tx / 2.5 + 1) * 0.5;
                  const ny = (ty / 2.5 + 1) * 0.5;
                  const nz = (tz / 2.5 + 1) * 0.5;
                  
                  targetX = lerp(rb.minX + r, rb.maxX - r, clamp(nx, 0, 1));
                  targetY = lerp(rb.minY + r, rb.maxY - r, clamp(ny, 0, 1));
                  targetZ = lerp(rb.minZ, rb.maxZ, clamp(nz, 0, 1));
                } else {
                  // Fallback to global bounds
                  targetX = (tx / 2.0) * (rightX - r);
                  targetY = bottomY + r + 0.5 + (0.5 + ty / 2.0) * (topY - bottomY - r * 2 - 1.0);
                  targetZ = (tz / 1.8) * (boundsNormal.z - r);
                }
                
                tmp.set(targetX - p.x, targetY - p.y, targetZ - p.z);
                // Stronger attraction to keep them in bounds
                v.addScaledVector(tmp, h * 0.25 * normalSpeedMul);
                
                // Increase collision radius and force for more uniform distribution
                if (doCollide) {
                  // Uniform Distribution Logic: Add repulsive force from other words regardless of close proximity
                  // Iterate through a few random neighbors to push away if too close
                  // Actually, the collision loop below handles 'collision'. 
                  // Here we add some random jitter to help escape local minima.
                  v.x += rand(-0.85, 0.85) * h * 0.35 * normalSpeedMul;
                  v.y += rand(-0.75, 0.75) * h * 0.35 * normalSpeedMul;
                  v.z += rand(-0.6, 0.6) * h * 0.35 * normalSpeedMul;
                }
                v.multiplyScalar(Math.exp(-airDragNormal * h));
                alpha[i] = 1;
              }

              const sp2 = v.lengthSq();
              const maxSpeed = mode[i] === 1 ? maxSpeedBlast : maxSpeedNormal;
              if (sp2 > maxSpeed * maxSpeed) v.multiplyScalar(maxSpeed / Math.sqrt(sp2));
              if (mode[i] === 0 && sp2 < 0.22) {
                v.x += rand(-0.55, 0.55) * normalSpeedMul;
                v.y += rand(-0.45, 0.45) * normalSpeedMul;
                v.z += rand(-0.45, 0.45) * normalSpeedMul;
              }

              p.addScaledVector(v, h);

              if (mode[i] === 0) {
                const rb = s.userData._region;
                let bx, leftX_local, by0, by1, bz_min, bz_max;
                
                if (rb) {
                   bx = rb.maxX - r;
                   leftX_local = rb.minX + r;
                   by0 = rb.minY + r;
                   by1 = rb.maxY - r;
                   bz_min = rb.minZ;
                   bz_max = rb.maxZ;
                } else {
                   bx = rightX - r;
                   leftX_local = leftX + r;
                   by0 = bottomY + r;
                   by1 = topY - r;
                   bz_min = -boundsNormal.z + r;
                   bz_max = boundsNormal.z - r;
                }
                
                if (p.x < leftX_local) { p.x = leftX_local; v.x = -v.x * wallE; }
                if (p.x > bx) { p.x = bx; v.x = -v.x * wallE; }
                
                if (p.y < by0) { p.y = by0; v.y = -v.y * wallE; }
                if (p.y > by1) { p.y = by1; v.y = -v.y * wallE; }
                
                if (p.z < bz_min) { p.z = bz_min; v.z = -v.z * wallE; }
                if (p.z > bz_max) { p.z = bz_max; v.z = -v.z * wallE; }
              }
            }

            if (doCollide) {
              for (let iter = 0; iter < 4; iter++) {
                for (let i = 0; i < sprites.length; i++) {
                  if (!alive[i] || mode[i] !== 0) continue;
                  const a = sprites[i];
                  const ra = a.userData._r || 0.8;
                  for (let j = i + 1; j < sprites.length; j++) {
                    if (!alive[j] || mode[j] !== 0) continue;
                    const b = sprites[j];
                    const rb = b.userData._r || 0.8;
                    const dx = a.position.x - b.position.x;
                    const dy = a.position.y - b.position.y;
                    const dz = a.position.z - b.position.z;
                    const dist2 = dx * dx + dy * dy + dz * dz;
                    // Increase collision radius multiplier to spread them out more (was ra+rb)
                    const r = (ra + rb) * 1.5; 
                    if (dist2 >= r * r) continue;
                    const dist = Math.sqrt(Math.max(1e-6, dist2));
                    nrm.set(dx / dist, dy / dist, dz / dist);
                    const penetration = r - dist;
                    // Stiffer response
                    const corr = penetration * 0.85; 
                    a.position.addScaledVector(nrm, corr * 0.5);
                    b.position.addScaledVector(nrm, -corr * 0.5);

                    const va = vel[i];
                    const vb = vel[j];
                    const rvx = va.x - vb.x;
                    const rvy = va.y - vb.y;
                    const rvz = va.z - vb.z;
                    const vn = rvx * nrm.x + rvy * nrm.y + rvz * nrm.z;
                    if (vn >= 0) continue;
                    const ma = Math.max(0.85, ra * ra);
                    const mb = Math.max(0.85, rb * rb);
                    const invA = 1.0 / ma;
                    const invB = 1.0 / mb;
                    const jImp = (-(1.0 + e) * vn) / (invA + invB);
                    va.x += (jImp * nrm.x) * invA;
                    va.y += (jImp * nrm.y) * invA;
                    va.z += (jImp * nrm.z) * invA;
                    vb.x -= (jImp * nrm.x) * invB;
                    vb.y -= (jImp * nrm.y) * invB;
                    vb.z -= (jImp * nrm.z) * invB;

                    va.multiplyScalar(0.998);
                    vb.multiplyScalar(0.998);
                  }
                }
              }
            }
          }

          for (let i = 0; i < sprites.length; i++) {
            if (!alive[i]) continue;
            const s = sprites[i];
            s.material.opacity = lerp(s.material.opacity, alpha[i] * wordState.dimTarget, 1 - Math.pow(0.001, dt));
            s.material.color.setScalar(1);
            s.rotation.z += wordState.ang[i] * dt * 0.22;
            s.rotation.x += wordState.ang[i] * dt * 0.08;
          }
        }

        const TrailShaders = {
          vertex: `
            precision highp float;
            attribute vec3 iHead;
            attribute vec3 iTail;
            attribute vec4 iColor;
            attribute float iAlpha;
            attribute float iWidth;
            attribute float iDelay;
            attribute float iGroup;
            uniform mat3 uBillboardRot;
            uniform vec3 uBillboardPivot;
            varying vec2 vUv;
            varying vec4 vColor;
            varying float vAlpha;
            varying float vDelay;
            varying float vGroup;
            void main() {
              vUv = uv;
              vColor = iColor;
              vAlpha = iAlpha;
              vDelay = iDelay;
              vGroup = iGroup;
              vec3 head = uBillboardPivot + uBillboardRot * (iHead - uBillboardPivot);
              vec3 tail = uBillboardPivot + uBillboardRot * (iTail - uBillboardPivot);
              vec4 headVS4 = modelViewMatrix * vec4(head, 1.0);
              vec4 tailVS4 = modelViewMatrix * vec4(tail, 1.0);
              vec3 headVS = headVS4.xyz;
              vec3 tailVS = tailVS4.xyz;
              vec3 dirVS = normalize(headVS - tailVS + vec3(1e-6));
              vec3 viewDir = normalize(-headVS);
              vec3 rightVS = normalize(cross(viewDir, dirVS));
              float side = (uv.x - 0.5) * 2.0;
              vec3 posVS = mix(tailVS, headVS, uv.y) + rightVS * side * iWidth;
              gl_Position = projectionMatrix * vec4(posVS, 1.0);
            }
          `,
          fragment: `
            precision highp float;
            varying vec2 vUv;
            varying vec4 vColor;
            varying float vAlpha;
            varying float vDelay;
            varying float vGroup;
            uniform float uTime;
            uniform vec3 uReveal3;
            uniform float uFlickerStrength;
            uniform float uSweepStrength;
            void main() {
              float x = abs(vUv.x - 0.5) * 2.0;
              float aa = fwidth(x);
              float body = 1.0 - smoothstep(1.0 - aa, 1.0 + aa, x);
              float core = exp(-x * x * 28.0);
              float edge = exp(-x * x * 10.0);
              float isSeg = step(2.5, vGroup);
              float isMeteor = step(42.5, vGroup);
              float bodySeg = exp(-x * x * 3.2);
              float bodyMeteor = exp(-x * x * 12.0);
              float bodySegMix = mix(bodySeg, bodyMeteor, isMeteor);
              body = mix(body, bodySegMix, isSeg);
              float y = clamp(vUv.y, 0.0, 1.0);
              float yaa = fwidth(y);
              float cap = smoothstep(0.0, 0.28 + yaa, y) * smoothstep(0.0, 0.28 + yaa, 1.0 - y);
              cap = mix(1.0, cap, isSeg * 0.55);
              float head = pow(y, 1.65);
              float trail = mix(0.14 + 0.86 * head, 0.52 + 0.12 * head, isSeg);
              float headY = 1.0 - y;
              float headSpot = exp(-x * x * 120.0) * exp(-headY * headY * 260.0);
              headSpot *= (1.0 - isSeg);
              headSpot *= (1.0 - 0.65 * isMeteor);
              float flickerRaw = 0.92 + 0.08 * sin(uTime * 19.0 + vColor.r * 7.0 + vColor.g * 11.0);
              float flicker = mix(1.0, flickerRaw, clamp(uFlickerStrength, 0.0, 1.0) * mix(1.0, 0.25, isSeg));
              float g0 = 1.0 - step(0.5, vGroup);
              float g2 = step(1.5, vGroup);
              float g1 = 1.0 - g0 - g2;
              float groupReveal = g0 * uReveal3.x + g1 * uReveal3.y + g2 * uReveal3.z;
              float reveal = smoothstep(vDelay - 0.07, vDelay + 0.07, groupReveal);
              float d = groupReveal - vDelay;
              float sweepStrength = clamp(uSweepStrength, 0.0, 1.0) * (1.0 - isSeg);
              float sweepCore = exp(-d * d * 140.0) * smoothstep(0.0, 0.03, d) * sweepStrength;
              float sweepTail = exp(-(d - 0.08) * (d - 0.08) * 55.0) * smoothstep(-0.02, 0.05, d) * sweepStrength;
              vec3 col = vColor.rgb;
              float a = vAlpha * flicker * reveal;
              float segSoft = mix(1.0, 0.92, isSeg);
              float edgeK = mix(0.22, 0.08, isMeteor);
              float coreK = mix(1.22, 1.7, isMeteor);
              float meteorAlpha = mix(1.0, 0.72, isMeteor);
              vec3 outCol = col * body * cap * segSoft * (trail * (edgeK * edge + coreK * core) + headSpot * 3.45);
              outCol += col * body * cap * segSoft * (sweepCore * 2.65 + sweepTail * 1.1) * (0.28 + 0.72 * core);
              float outA =
                body * cap * segSoft * (a * meteorAlpha * (0.95 * trail + 1.55 * headSpot) + vAlpha * (sweepCore * 0.85 + sweepTail * 0.28));
              gl_FragColor = vec4(outCol, outA);
            }
          `,
        };

        const DotShaders = {
          vertex: `
            precision highp float;
            attribute vec3 iHead;
            attribute vec3 iTail;
            attribute vec4 iColor;
            attribute float iAlpha;
            attribute float iWidth;
            attribute float iDelay;
            attribute float iGroup;
            uniform mat3 uBillboardRot;
            uniform vec3 uBillboardPivot;
            varying vec2 vUv;
            varying vec4 vColor;
            varying float vAlpha;
            varying float vDelay;
            varying float vGroup;
            void main() {
              vUv = uv;
              vColor = iColor;
              vAlpha = iAlpha;
              vDelay = iDelay;
              vGroup = iGroup;
              vec3 head = uBillboardPivot + uBillboardRot * (iHead - uBillboardPivot);
              vec4 pVS4 = modelViewMatrix * vec4(head, 1.0);
              vec3 pVS = pVS4.xyz;
              vec3 viewDir = normalize(-pVS);
              vec3 upRef = vec3(0.0, 1.0, 0.0);
              vec3 rightVS = normalize(cross(upRef, viewDir));
              vec3 upVS = normalize(cross(viewDir, rightVS));
              vec2 q = (uv - 0.5) * 2.0;
              float sz = iWidth * 1.65;
              vec3 posVS = pVS + rightVS * (q.x * sz) + upVS * (q.y * sz);
              gl_Position = projectionMatrix * vec4(posVS, 1.0);
            }
          `,
          fragment: `
            precision highp float;
            varying vec2 vUv;
            varying vec4 vColor;
            varying float vAlpha;
            varying float vDelay;
            varying float vGroup;
            uniform float uTime;
            uniform vec3 uReveal3;
            uniform float uSparkleStrength;
            uniform float uScanStrength;
            void main() {
              vec2 q = (vUv - 0.5) * 2.0;
              float r = length(q);
              float aa = fwidth(r);
              float disc = 1.0 - smoothstep(1.0 - aa, 1.0 + aa, r);

              float g0 = 1.0 - step(0.5, vGroup);
              float g2 = step(1.5, vGroup);
              float g1 = 1.0 - g0 - g2;
              float groupReveal = g0 * uReveal3.x + g1 * uReveal3.y + g2 * uReveal3.z;
              float d = groupReveal - vDelay;
              float reveal = smoothstep(0.0, 0.06, d);
              float scan = exp(-d * d * 60.0) * smoothstep(-0.08, 0.06, d) * clamp(uScanStrength, 0.0, 1.0);

              float core = exp(-r * r * 3.2);
              float sparkleRaw = 0.92 + 0.08 * sin(uTime * 17.0 + vColor.r * 9.0 + vColor.g * 13.0);
              float sparkle = mix(1.0, sparkleRaw, clamp(uSparkleStrength, 0.0, 1.0));
              vec3 col = vColor.rgb * (0.25 + 0.75 * core);
              col += vColor.rgb * scan * 1.6;
              float a = vAlpha * sparkle * disc * (reveal * 0.95 + scan * 0.85);
              gl_FragColor = vec4(col, a);
            }
          `,
        };

        class TrailParticleSystem {
          constructor(maxInstances) {
            this.max = maxInstances;
            this.count = 0;

            this.pos = new Float32Array(this.max * 3);
            this.vel = new Float32Array(this.max * 3);
            this.col = new Float32Array(this.max * 4);
            this.life = new Float32Array(this.max);
            this.age = new Float32Array(this.max);
            this.kind = new Uint8Array(this.max);
            this.alive = new Uint8Array(this.max);
            this.prevPos = new Float32Array(this.max * 3);
            this.trailAcc = new Float32Array(this.max);

            this.iHead = new Float32Array(this.max * 3);
            this.iTail = new Float32Array(this.max * 3);
            this.iColor = new Float32Array(this.max * 4);
            this.iAlpha = new Float32Array(this.max);
            this.iWidth = new Float32Array(this.max);
            this.iDelay = new Float32Array(this.max);
            this.iGroup = new Float32Array(this.max);
            
            // Optimization: Free List Stack
            this.freeStack = new Int32Array(this.max);
            this.freeCount = 0;

            const base = new THREE.PlaneGeometry(1, 1, 1, 1);
            const g = new THREE.InstancedBufferGeometry();
            g.index = base.index;
            g.attributes.position = base.attributes.position;
            g.attributes.uv = base.attributes.uv;
            g.instanceCount = 0;
            g.setAttribute("iHead", new THREE.InstancedBufferAttribute(this.iHead, 3));
            g.setAttribute("iTail", new THREE.InstancedBufferAttribute(this.iTail, 3));
            g.setAttribute("iColor", new THREE.InstancedBufferAttribute(this.iColor, 4));
            g.setAttribute("iAlpha", new THREE.InstancedBufferAttribute(this.iAlpha, 1));
            g.setAttribute("iWidth", new THREE.InstancedBufferAttribute(this.iWidth, 1));
            g.setAttribute("iDelay", new THREE.InstancedBufferAttribute(this.iDelay, 1));
            g.setAttribute("iGroup", new THREE.InstancedBufferAttribute(this.iGroup, 1));

            const m = new THREE.ShaderMaterial({
              vertexShader: TrailShaders.vertex,
              fragmentShader: TrailShaders.fragment,
              transparent: true,
              depthWrite: false,
              depthTest: false,
              side: THREE.DoubleSide,
              blending: THREE.AdditiveBlending,
              uniforms: {
                uTime: { value: 0 },
                uReveal3: { value: new THREE.Vector3(1, 1, 1) },
                uFlickerStrength: { value: 1.0 },
                uSweepStrength: { value: 1.0 },
                uBillboardRot: { value: new THREE.Matrix3() },
                uBillboardPivot: { value: new THREE.Vector3() },
              },
            });

            this.geometry = g;
            this.material = m;
            this.mesh = new THREE.Mesh(g, m);
            this.mesh.frustumCulled = false;
          }

          kill(idx) {
            if (idx < 0 || idx >= this.max) return;
            if (!this.alive[idx]) return;
            const base = idx * 3;
            const px = this.pos[base + 0];
            const py = this.pos[base + 1];
            const pz = this.pos[base + 2];
            this.alive[idx] = 0;
            this.iAlpha[idx] = 0;
            this.iWidth[idx] = 0;
            this.iHead[base + 0] = px;
            this.iHead[base + 1] = py;
            this.iHead[base + 2] = pz;
            this.iTail[base + 0] = px;
            this.iTail[base + 1] = py;
            this.iTail[base + 2] = pz;
            this.prevPos[base + 0] = px;
            this.prevPos[base + 1] = py;
            this.prevPos[base + 2] = pz;
            this.trailAcc[idx] = 0;
            
            // Push to free stack
            this.freeStack[this.freeCount++] = idx;
          }

          spawnParticle(p, v, color, life, kind) {
            let idx = -1;
            
            // Try pop from free stack first (O(1))
            if (this.freeCount > 0) {
                idx = this.freeStack[--this.freeCount];
            } else if (this.count < this.max) {
                idx = this.count++;
            } else {
              // Pool is full, force recycle
              // 保护策略：绝对禁止回收 kind=4 (Emitter) 和 kind=0 (Rocket) 的粒子
              // 尝试随机找 30 次
              for(let t=0; t<30; t++) {
                 const rnd = (Math.random() * this.max) | 0;
                 const k = this.kind[rnd];
                 if (k !== 0 && k !== 4) {
                    idx = rnd;
                    break;
                 }
              }
              if (idx === -1 && (kind === 0 || kind === 4)) {
                 idx = (Math.random() * this.max) | 0;
              }
            }
            if (idx === -1) return -1;

            this.alive[idx] = 1;
            this.age[idx] = 0;
            this.life[idx] = life;
            this.kind[idx] = kind;
            this.pos[idx * 3 + 0] = p.x;
            this.pos[idx * 3 + 1] = p.y;
            this.pos[idx * 3 + 2] = p.z;
            this.vel[idx * 3 + 0] = v.x;
            this.vel[idx * 3 + 1] = v.y;
            this.vel[idx * 3 + 2] = v.z;
            this.prevPos[idx * 3 + 0] = p.x;
            this.prevPos[idx * 3 + 1] = p.y;
            this.prevPos[idx * 3 + 2] = p.z;
            this.trailAcc[idx] = 0;
            this.col[idx * 4 + 0] = color.r;
            this.col[idx * 4 + 1] = color.g;
            this.col[idx * 4 + 2] = color.b;
            this.col[idx * 4 + 3] = 1;
            this.iDelay[idx] = 0;
            this.iGroup[idx] = 0;
            return idx;
          }

          update(dt, t, stage) {
            this.material.uniforms.uTime.value = t;
            this.material.uniforms.uReveal3.value.set(1, 1, 1);
            const g = CONFIG.fireworks.gravity * (CONFIG.fireworks.speedScale || 1);
            const f = CONFIG.fireworks.friction;
            const dtSafe = clamp(dt, 0, 0.05);
            const useSegmentTrails = stage <= 4;
            const dtFrames = dtSafe * 60;
            const dragExplosionXZ = Math.pow(0.999, dtFrames);
            const dragExplosionAscentY = Math.pow(0.98, dtFrames);
            const dragRocketXZ = Math.pow(0.995, dtFrames);
            const dragRocketY = Math.pow(0.998, dtFrames);
            const dragDefault = Math.pow(f, dtFrames);
            const secondaryTriggerP = 1 - Math.pow(1 - 0.03, dtFrames);
            const camPos = camera ? camera.position : null;
            const _p = TrailParticleSystem._tmpP || (TrailParticleSystem._tmpP = new THREE.Vector3());
            const _v = TrailParticleSystem._tmpV || (TrailParticleSystem._tmpV = new THREE.Vector3());
            const _c = TrailParticleSystem._tmpC || (TrailParticleSystem._tmpC = new THREE.Color());

            let aliveCount = 0;
            let lastAliveIdx = -1;
            let seg4Count = 0;
            let seg4MaxWidth = 0;
            let seg44Count = 0;
            let seg44MaxWidth = 0;
            for (let i = 0; i < this.count; i++) {
              if (!this.alive[i]) continue;
              lastAliveIdx = i;
              const base = i * 3;
              let px = this.pos[base + 0];
              let py = this.pos[base + 1];
              let pz = this.pos[base + 2];
              let vx = this.vel[base + 0];
              let vy = this.vel[base + 1];
              let vz = this.vel[base + 2];
              const ppx = this.prevPos[base + 0];
              const ppy = this.prevPos[base + 1];
              const ppz = this.prevPos[base + 2];

              const k = this.kind[i];
          // 减缓爆炸动画速度30% (effectiveDt * 0.7)
          const effectiveDt = (k === 1 || k === 3) ? dtSafe * 0.25 * 0.7 : dtSafe;
          const age = (this.age[i] += effectiveDt);
              const life = this.life[i];
              let a = 1.0 - age / life;
              if (a <= 0) {
                this.alive[i] = 0;
                this.iAlpha[i] = 0;
                this.iWidth[i] = 0;
                this.iHead[base + 0] = px;
                this.iHead[base + 1] = py;
                this.iHead[base + 2] = pz;
                this.iTail[base + 0] = px;
                this.iTail[base + 1] = py;
                this.iTail[base + 2] = pz;
                this.prevPos[base + 0] = px;
                this.prevPos[base + 1] = py;
                this.prevPos[base + 2] = pz;
                this.trailAcc[i] = 0;
                continue;
              }
              a =
                k === 1 || k === 3 || k === 7
                  ? Math.pow(a, 2.35)
                  : k === 0 || k === 4
                  ? Math.pow(a, 1.75)
                  : k === 5
                  ? Math.pow(a, 1.0)
                  : k === 2
                  ? Math.pow(a, 1.55)
                  : k === 6
                  ? Math.pow(a, 2.55)
                  : Math.pow(a, 1.15);
              if (k === 4) {
              } else if (k === 6) {
              } else if (k === 7) {
                  // 二次爆炸粒子下落速度减缓50%
                  // 正常重力是 g * effectiveDt * 7.8
                  vx *= dragExplosionXZ;
                  vz *= dragExplosionXZ;
                  
                  if (vy > 0) {
                      vy = vy - g * effectiveDt * 1.5;
                      vy *= dragExplosionAscentY;
                  } else {
                      // 再次减缓40%的下落重力 (3.9 * 0.6 = 2.34)
                      vy = vy - g * effectiveDt * 2.34;
                  }
              } else if (k === 1 || k === 3) {
                vx *= dragExplosionXZ;
                vz *= dragExplosionXZ;
                
                if (vy > 0) {
                  // 上升阶段：保持缓慢，增加阻力
                  vy = vy - g * effectiveDt * 1.5;
                  vy *= dragExplosionAscentY;
                } else {
                  // 下落阶段：触发下落，不再飘在空中
                  // 大幅增加重力影响 (was 6.0 -> 7.8)
                  vy = vy - g * effectiveDt * 7.8;
                }

                // 二次爆炸逻辑：巨型烟花(k=3)且标记为有二次爆炸(iGroup=1)且处于下落阶段
                if (k === 3 && this.iGroup[i] === 1 && vy < -0.2) {
                   if (Math.random() < secondaryTriggerP) {
                     this.alive[i] = 0;
                     this.iAlpha[i] = 0;
                     this.iWidth[i] = 0;
                     // 触发小型二次爆炸
                     _p.set(px, py, pz);
                     _c.fromArray(this.col, i * 4);
                     // 粒子数减少(12个)，力度减小(5.0)
                     explodeSecondary(_p, _c);
                     continue;
                   }
                }
                if (k === 3 && this.iGroup[i] === 2) {
                  const raw = this.iDelay[i] || 0;
                  const delay = raw > 0 && raw < 1.2 ? raw * life : raw;
                  if (age >= delay) {
                    this.alive[i] = 0;
                    this.iAlpha[i] = 0;
                    this.iWidth[i] = 0;
                    _p.set(px, py, pz);
                    _c.fromArray(this.col, i * 4);
                    explodeSecondary(_p, _c);
                    continue;
                  }
                }
              } else if (k === 5) {
                // Dying rocket head: rapid deceleration (drag)
                vx *= 0.85;
                vz *= 0.85;
                vy *= 0.85;
              } else if (k === 0 || k === 2) {
                vx *= dragRocketXZ;
                vz *= dragRocketXZ;
                vy = vy * dragRocketY - g * effectiveDt * 0.78;
              } else {
                vx *= dragDefault;
                vz *= dragDefault;
                vy = vy * dragDefault - g * effectiveDt;
              }

              if (k !== 4 && k !== 6 && k !== 5) {
                px += vx * effectiveDt;
                py += vy * effectiveDt;
                pz += vz * effectiveDt;
              }

              this.pos[base + 0] = px;
              this.pos[base + 1] = py;
              this.pos[base + 2] = pz;
              this.vel[base + 0] = vx;
              this.vel[base + 1] = vy;
              this.vel[base + 2] = vz;
              this.prevPos[base + 0] = px;
              this.prevPos[base + 1] = py;
              this.prevPos[base + 2] = pz;

              const segFromEmitter = k === 4;
              const segFromRocket = k === 0 && (useSegmentTrails || this.iGroup[i] === 45);
              const segFromSpark = useSegmentTrails && k === 2;
              if (segFromEmitter || segFromRocket || segFromSpark) {
                const dx = px - ppx;
                const dy = py - ppy;
                const dz = pz - ppz;
                const dl = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const tag = segFromEmitter ? this.iGroup[i] : 0;
                // 统一优化：所有发射源(火箭、特殊烟花部件)都使用超高密度插值
                // 性能评估：发射源数量少(通常<50个)，即使增加几十倍插值点，总粒子数增量也在可控范围内(几千级别)，
                // 远低于显卡渲染瓶颈(数万/数十万)，因此可以放心使用极高密度以换取极致平滑。
                
                const interval = 0.001; // 只要有时间流逝就尝试生成
                const minDl = 0.0001;   // 只要有极微小的位移就生成
                
                this.trailAcc[i] += dtSafe;
                if (this.trailAcc[i] >= interval && dl > minDl) {
                  this.trailAcc[i] = 0;
                  const invDt = 1.0 / Math.max(1e-6, dtSafe);
                  _v.set(dx * invDt, dy * invDt, dz * invDt);
                  const curSpeed = dl * invDt;
                  _c.fromArray(this.col, i * 4);
                  
                  // 生命周期微调：不同类型的尾迹长度略有不同
                  // 螺旋上升(tag=41)加长60% (1.35 -> 2.16)
                  // tag=46 (冠状小火箭) 加长到 2.2s (原3.0s) 以优化性能
                  // 水帘(tag=43) 尾迹变长 (1.15 -> 2.5)
                  const segLife = segFromEmitter 
                    ? (tag === 44 ? 1.45 : tag === 41 ? 2.16 : tag === 46 ? 2.2 : tag === 42 ? 1.35 : tag === 43 ? 4.2 : 1.85) 
                    : segFromRocket ? clamp(7.2 / Math.max(2.0, curSpeed), 0.35, 6.0) : 0.75;
                  
                  // 核心优化：动态计算插值数量
                  // 统一高密度：所有尾迹默认 dl / 0.005
                  // 特殊优化：超长尾迹(双火箭42/44、螺旋41、水帘源43)密度再翻倍 dl / 0.0025，确保绝对丝滑
                  // 注意：移除了 tag=46 (冠状小火箭) 的超高密度，降级为普通高密度(0.005)，以解决第四支烟花卡顿问题
                  // 第一束烟花(segFromSpark)密度再翻倍 dl / 0.0025
                  // 螺旋上升(tag=41)插值密度再翻一番 -> dl / 0.00125
                  let densityDiv = 0.005;
                  if (tag === 42 || tag === 44 || tag === 43 || segFromSpark) densityDiv = 0.0025;
                  if (tag === 41) densityDiv = 0.00125;
                  
                  const segN = Math.min(320, Math.max(1, Math.ceil(dl / densityDiv)));
                  
                  const segTag = segFromEmitter ? (tag >= 40 ? tag : 42) : 3;
                  for (let si = 0; si < segN; si++) {
                    const t0 = si / segN;
                    const t1 = (si + 1) / segN;
                    const hx = ppx + dx * t1;
                    const hy = ppy + dy * t1;
                    const hz = ppz + dz * t1;
                    const tx = ppx + dx * t0;
                    const ty = ppy + dy * t0;
                    const tz = ppz + dz * t0;
                    _p.set(hx, hy, hz);
                    const segIdx = this.spawnParticle(_p, _v, _c, segLife, 6);
                    if (segIdx !== -1) {
                      const sb = segIdx * 3;
                      this.iGroup[segIdx] = segTag;
                      this.iHead[sb + 0] = hx;
                      this.iHead[sb + 1] = hy;
                      this.iHead[sb + 2] = hz;
                      this.iTail[sb + 0] = tx;
                      this.iTail[sb + 1] = ty;
                      this.iTail[sb + 2] = tz;
                      this.vel[sb + 0] = 0;
                      this.vel[sb + 1] = 0;
                      this.vel[sb + 2] = 0;
                    }
                  }
                }
              } else {
                this.trailAcc[i] = 0;
              }

              const rawSpeed = Math.sqrt(vx * vx + vy * vy + vz * vz);
              let speed = rawSpeed + 1e-5;
              let inv = 1.0 / speed;
              let nx = vx * inv;
              let ny = vy * inv;
              let nz = vz * inv;
              if ((k === 0 || k === 4) && rawSpeed < 0.42) {
                const pdx = this.iHead[base + 0] - this.iTail[base + 0];
                const pdy = this.iHead[base + 1] - this.iTail[base + 1];
                const pdz = this.iHead[base + 2] - this.iTail[base + 2];
                const plen = Math.sqrt(pdx * pdx + pdy * pdy + pdz * pdz);
                if (plen > 1e-4) {
                  const pinv = 1.0 / plen;
                  nx = pdx * pinv;
                  ny = pdy * pinv;
                  nz = pdz * pinv;
                } else {
                  nx = 0;
                  ny = vy >= 0 ? 1 : -1;
                  nz = 0;
                }
              }

              const trailBase =
                k === 0 || k === 4
                  ? CONFIG.visuals.trails.rocketLength
                  : k === 5
                  ? CONFIG.visuals.trails.rocketLength
                  : k === 2
                  ? CONFIG.visuals.trails.sparkLength
                  : k === 3
                  ? 0.48 // Giant explosion: 4 particle sizes
                  : k === 7
                  ? 0.42 // Secondary: slightly shorter than parent (0.48) but slender
                  : CONFIG.visuals.trails.explosionLength;
              let lenScale = clamp(speed * 0.14, 0.65, 2.4);
              if (k === 0 || k === 5) lenScale = 0.72;

              let len =
                k === 6
                  ? this.iGroup[i] === 41
                    ? CONFIG.visuals.trails.rocketLength * 0.22
                    : this.iGroup[i] === 42
                    ? CONFIG.visuals.trails.rocketLength * 0.2
                    : this.iGroup[i] === 44
                    ? CONFIG.visuals.trails.rocketLength * 0.14
                    : CONFIG.visuals.trails.rocketLength * 0.16
                  : trailBase * lenScale;
              if (k === 5) len *= a; // Shrink length as it fades
              if ((useSegmentTrails && (k === 0 || k === 2)) || (k === 0 && this.iGroup[i] === 45)) len = 0.12;
              if (k === 4) len = 0;
              if (k !== 6 && k !== 5) {
                this.iHead[base + 0] = px;
                this.iHead[base + 1] = py;
                this.iHead[base + 2] = pz;
                if (k === 4) {
                  this.iTail[base + 0] = px;
                  this.iTail[base + 1] = py;
                  this.iTail[base + 2] = pz;
                } else {
                  this.iTail[base + 0] = px - nx * len;
                  this.iTail[base + 1] = py - ny * len;
                  this.iTail[base + 2] = pz - nz * len;
                }
              }
              this.iColor[i * 4 + 0] = this.col[i * 4 + 0];
              this.iColor[i * 4 + 1] = this.col[i * 4 + 1];
              this.iColor[i * 4 + 2] = this.col[i * 4 + 2];
              this.iColor[i * 4 + 3] = 1;
              this.iAlpha[i] =
                a *
                (k === 0
                  ? 0.88
                  : k === 5
                  ? this.iDelay[i] // Use stored base alpha for smooth fade
                  : k === 4
                  ? 0.0
                  : k === 2
                  ? 1.15
                  : k === 6
                  ? this.iGroup[i] >= 40
                    ? 0.34
                    : 0.62
                  : 0.95);
              const w0 = CONFIG.visuals.trails.width;
              // 粒子大小增大100% (2倍)
              let wBase =
                k === 0
                  ? w0 * 0.666
                  : k === 5
                  ? w0 * 0.666
                  : k === 4
                  ? 0.0
                  : k === 2
                  ? w0 * 0.96
                  : k === 7
                  ? CONFIG.visuals.trails.widthExplosion * 0.95 // Match explosion width (thick) instead of thin
                  : k === 6
                  ? this.iGroup[i] === 44
                    ? w0 * 2.6
                    : this.iGroup[i] >= 40
                    ? w0 * 2.6
                    : w0 * 1.15
                  : CONFIG.visuals.trails.widthExplosion;
              if (k === 6 && this.iGroup[i] >= 40 && camPos) {
                const dx = px - camPos.x;
                const dy = py - camPos.y;
                const dz = pz - camPos.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const distScale = clamp(dist / 16.0, 1.0, 4.8);
                wBase *= distScale * 0.44;
              }
              if (k === 6 && this.iGroup[i] === 44) wBase *= 1.25;
              this.iWidth[i] = wBase * 2.0;

              if (k === 6 && this.iGroup[i] >= 40) {
                seg4Count++;
                const w = this.iWidth[i];
                if (w > seg4MaxWidth) seg4MaxWidth = w;
              }
              if (k === 6 && this.iGroup[i] === 44) {
                seg44Count++;
                const w = this.iWidth[i];
                if (w > seg44MaxWidth) seg44MaxWidth = w;
              }
              aliveCount++;
            }

            this.geometry.instanceCount = Math.max(0, lastAliveIdx + 1);
            this.geometry.attributes.iHead.needsUpdate = true;
            this.geometry.attributes.iTail.needsUpdate = true;
            this.geometry.attributes.iColor.needsUpdate = true;
            this.geometry.attributes.iAlpha.needsUpdate = true;
            this.geometry.attributes.iWidth.needsUpdate = true;
            this.geometry.attributes.iDelay.needsUpdate = true;
            this.geometry.attributes.iGroup.needsUpdate = true;

            this._seg4Count = seg4Count;
            this._seg4MaxWidth = seg4MaxWidth;
            this._seg44Count = seg44Count;
            this._seg44MaxWidth = seg44MaxWidth;
            return aliveCount;
          }
        }

        const particles = new TrailParticleSystem(CONFIG.maxParticles);
        scene.add(particles.mesh);

        const spark = {
          active: false,
          idx: -1,
          t: 0,
          duration: 1.6,
          // 第一束烟花位置上调: y=4.0 (2.0 + 1/4 countdown height)
          apex: new THREE.Vector3(0, 4.0, 0),
        };

        const stageState = {
          paused: false,
          stage: 1,
          started: false,
          stageT: 0,
          countdownLeft: CONFIG.stage.countdownSeconds,
          countdownShown: 0,
          fireworksT: 0,
          finaleT: 0,
          clickArmed: true,
          _blessingTimers: [],
          _audioPools: null,
          _activeSounds: 0,
          _soundNextAt: 0,
        };

        function createDigitMesh(num) {
          const group = new THREE.Group();
          const mat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            emissive: 0xffffff,
            emissiveIntensity: 2.8,
            metalness: 0.1,
            roughness: 0.35,
          });
          const thick = 0.22;
          const segLen = 1.32;
          const segWide = 0.26;
          const boxH = new THREE.BoxGeometry(segLen, segWide, thick);
          const boxV = new THREE.BoxGeometry(segWide, segLen, thick);

          const segPos = {
            a: [0, 1.1],
            b: [0.66, 0.45],
            c: [0.66, -0.65],
            d: [0, -1.2],
            e: [-0.66, -0.65],
            f: [-0.66, 0.45],
            g: [0, -0.05],
          };
          const map = {
            0: ["a", "b", "c", "d", "e", "f"],
            1: ["b", "c"],
            2: ["a", "b", "g", "e", "d"],
            3: ["a", "b", "g", "c", "d"],
            4: ["f", "g", "b", "c"],
            5: ["a", "f", "g", "c", "d"],
            6: ["a", "f", "g", "e", "c", "d"],
            7: ["a", "b", "c"],
            8: ["a", "b", "c", "d", "e", "f", "g"],
            9: ["a", "b", "c", "d", "f", "g"],
          };
          const segs = map[num] || map[3];
          for (const s of segs) {
            const isH = s === "a" || s === "d" || s === "g";
            const geom = isH ? boxH : boxV;
            const mesh = new THREE.Mesh(geom, mat);
            const p = segPos[s];
            mesh.position.set(p[0], p[1], 0);
            group.add(mesh);
          }
          group.scale.setScalar(1.15);
          return group;
        }

        const light = new THREE.AmbientLight(0xffffff, 0.25);
        scene.add(light);
        const key = new THREE.DirectionalLight(0xffffff, 0.35);
        key.position.set(4, 7, 3);
        scene.add(key);

        const countdown = {
          group: new THREE.Group(),
          current: null,
          shown: false,
          t: 0,
        };
        countdown.group.position.set(0, 3.8, 4.8);
        scene.add(countdown.group);

        function setCountdownDigit(d) {
          if (countdown.current) countdown.group.remove(countdown.current);
          countdown.current = createDigitMesh(d);
          // 每次旋转重置角度减少10度 (0.175弧度)
          const baseRy = 0.55 - (3 - d) * 0.175;
          // "1"为轴即Y轴。顺时针旋转15度即-0.26弧度。
          // baseRy在d=3时为0.55。要得到-0.26，需要减去0.81
          countdown.current.rotation.set(0.14, baseRy - 0.81, 0);
          countdown.current.traverse((o) => {
            if (o && o.isMesh) o.renderOrder = 50;
          });
          countdown.group.add(countdown.current);
        }

        function showCountdown() {
          countdown.shown = true;
          countdown.t = 0;
          setCountdownDigit(3);
          countdown.group.visible = true;
          countdown.group.scale.setScalar(1);
        }

        function hideCountdown() {
          countdown.shown = false;
          countdown.group.visible = false;
        }

        const introTextState = {
          current: null,
          group: new THREE.Group(),
        };
        scene.add(introTextState.group);

        function showIntroText(text, options) {
          if (introTextState.current) {
            introTextState.group.remove(introTextState.current);
            introTextState.current = null;
          }
          if (!text) return;
          
          const opt = Object.assign({
              color: "#00ffff", // Tech Cyan
              shadow: "#008B8B",
              stroke: "rgba(0,0,0,0)", // No black stroke
              fontSize: 120,
              fontFamily: '"Segoe UI", "Roboto", "Helvetica Neue", sans-serif',
              scale: 1.0
           }, options || {});
           
           const sprite = createTextSprite(text, opt);
           // Position at countdown location: 0, 3.8, 4.8
           sprite.position.set(0, 3.8, 4.8);
           // Scale calculation: 
           // createTextSprite scales to (w/240, h/240). 
           // If fontSize=120, h~160. 160/240 = 0.66.
           // Target height ~2.5 (Countdown size). 2.5 / 0.66 = 3.8.
           // Let's use scale multiplier 4.0.
           const baseScale = opt.scale || 1.0;
           sprite.scale.multiplyScalar(4.0 * baseScale);
           
           introTextState.current = sprite;
           introTextState.group.add(sprite);
         }

        function hideIntroText() {
           if (introTextState.current) {
              introTextState.group.remove(introTextState.current);
              introTextState.current = null;
           }
        }

        function startLongTextSequence() {
          stageState.stage = 8;
          stageState.stageT = 0;
          
          stopMorphImmediately();
          killActiveParticles();
          
          const container = document.getElementById("longTextContainer");
          if (!container) {
             startStage6Blessing();
             return;
          }
          
          container.innerHTML = "";
          container.style.display = "block";
          container.style.opacity = "1";
          
          const lines = [
            "允许自己并不完美，",
            "只要在喧嚣中守住清朗；",
            "接受自己平平无奇，",
            "即使力有不逮也会努力迈开脚步。",
            "",
            "不必追赶他人的脚步，",
            "也不必活成世俗定义的样子，",
            "舒坦，",
            "不是躺平摆烂，",
            "而是在接纳生活真相后，",
            "依然选择热爱。",
            "", 
            "2026，",
            "让我们带着滚烫的真心，",
            "奔赴每一个平凡的日子，",
            "从容不迫，不叹遗憾，",
            "向暖而行，万事安然。",
            "" 
          ];
          
          let delay = 0;
          const lineDelay = 3200; // ms (further slowed down +800ms)
          
          lines.forEach((text, i) => {
            if (text === "") {
                 const br = document.createElement("div");
                 br.style.height = "24px";
                 container.appendChild(br);
                 return;
            }
            
            const div = document.createElement("div");
            div.className = "long-text-line";
            div.textContent = text;
            container.appendChild(div);
            
            setTimeout(() => {
                div.classList.add("visible");
            }, delay);
            
            delay += lineDelay;
          });
          
          const totalTime = delay + 4000;
          
          setTimeout(() => {
              container.style.transition = "opacity 1.5s ease-out";
              container.style.opacity = "0";
              setTimeout(() => {
                  container.style.display = "none";
                  container.style.opacity = "1";
                  container.style.transition = "";
                  startStage6Blessing();
              }, 1500);
          }, totalTime);
        }

        function startIntroTextSequence() {
          stageState.stage = 25;
          stageState.stageT = 0;
          stageState.introPhase = 0; // 0: Hey, 1: Gap, 2: HNY, 3: Gap
          
          // Clear any particle texts just in case
           stopMorphImmediately();
           
           // Show "Hey!"
           showIntroText("Hey!", { fontSize: 100, scale: 0.75, color: "#7DF9FF", shadow: "rgba(0,255,255,0.6)" });
         }

        function startStage2() {
          stageState.stage = 2;
          stageState.stageT = 0;
          stageState.countdownLeft = CONFIG.stage.countdownSeconds;
          stageState.countdownShown = 3;
          if (typeof soundManager !== "undefined") {
            soundManager.startThingsBgm();
          }
          showCountdown();
          DEBUG.log("stage=2 countdown start");
        }

        function startSparkAndBlast() {
          stageState.stage = 3;
          stageState.stageT = 0;
          spark.active = true;
          spark.t = 0;
          
          // Reset launch sound counter and timer for Stage 4
          stageState._launchSoundCount = 0;
          stageState._lastLaunchSoundTime = 0;

          const start = new THREE.Vector3(0, -1.2, 0);
        const s = CONFIG.fireworks.speedScale || 1;
        // Increase initial velocity to ensure it reaches higher apex (y=4.0)
        // Old v.y = 12.8. h = v^2/2g. 12.8^2/20 = 8.
        // It should be enough, but maybe drag reduces it?
        // Let's bump it to 16.0 just in case.
        const v = new THREE.Vector3(0, 16.0 * s, 0);
          const c = new THREE.Color("#ffcc55");
          spark.idx = particles.spawnParticle(start, v, c, spark.duration / s, 2);
          spark._dur = spark.duration / s;
          DEBUG.log("stage=3 spark spawn", { idx: spark.idx });
          
          // First Firework Launch Sound
          if (typeof soundManager !== 'undefined') {
             // User Request: Use firstl.m4a for the first firework launch
             const audio = soundManager.play('firstl', { pitch: 1.0, volume: 1.0, force: true });
             if (audio) spark._launchAudio = audio;
          }
        }


        
        function isBlessingStage() {
          return stageState.stage === 4 || stageState.stage === 7 || stageState.stage === 25;
        }

        function pickBlessingWord() {
          if (!stageState._blessingBag || stageState._blessingBag.length === 0) {
             const blessings = [
               "发量惊人", "吃不胖", "好梦", "拒绝焦虑", "准点下班",
               "秒过", "期末满绩", "暴富预定", "告别内耗", "情绪稳定",
               "中彩票", "连胜", "考神附体", "桃花朵朵", "社交牛逼",
               "远离伤病", "球技暴涨", "钱包鼓鼓", "搞到真钱", "甲方听话",
               "不脆皮", "皮肤超好", "wifi满格", "天才", "外卖凑满减",
               "真的不累", "运气爆棚", "告别黑眼圈", "精神百倍", "不崴脚"
             ];
             // Shuffle
             for (let i = blessings.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [blessings[i], blessings[j]] = [blessings[j], blessings[i]];
             }
             stageState._blessingBag = blessings;
          }
          return stageState._blessingBag.pop();
        }

        function stopMorphImmediately() {
          if (stageState._blessingTimers) {
            stageState._blessingTimers.forEach(t => clearTimeout(t));
            stageState._blessingTimers = [];
          }
          if (!morph || !morph.geom) return;
          morph.active = false;
          morph.liveCount = 0;
          morph.geom.instanceCount = 0;
          if (morph.dotMesh) morph.dotMesh.visible = false;
          if (morph.mesh) morph.mesh.visible = false;
        }

        function triggerBlessingDissolve() {
          morph.useDots = true;
          morph.phase = 3;
          morph.mesh.visible = false;
          morph.dotMesh.visible = true;
          morph.locked = false;
          morph.windActive = false; 
          morph.gravityDissolve = true;
          morph.windT = 0;
          morph.reveal3.set(999, 999, 999);
          
          const n = morph.liveCount || 0;
          
          for (let i = 0; i < n; i++) {
            const b3 = i * 3;
            // Natural dissipation: random drift + gravity
            morph.vel[b3+0] = rand(-1.5, 1.5);
            morph.vel[b3+1] = rand(-0.5, 1.0); 
            morph.vel[b3+2] = rand(-1.5, 1.5);
            
            // Sync pos with target (start from text shape)
            morph.pos[b3+0] = morph.target[b3+0];
            morph.pos[b3+1] = morph.target[b3+1];
            morph.pos[b3+2] = morph.target[b3+2];
            
            morph.delay[i] = 0;
          }
          morph.geom.attributes.iDelay.needsUpdate = true;
        }

        function triggerBlessingTexts(items, sourceParticles = null) {
          if (!isBlessingStage()) {
             return;
          }
          if (!items || !items.length) {
             return;
          }

          const gold = new THREE.Color("#ffcc66");
          
          resetMorphText(true); // Always reset morph state to avoid old particles persisting
          morph.active = true;
          morph.fadeIn = 1.0; 
          morph.windAlphaScale = 0.68;
          morph.dotMesh.visible = true;
          morph.mesh.visible = false;
          morph.frozen = false; 
          
          // Clear morph data BEFORE populating new items
          // This prevents old text from lingering if new text has fewer points
          morph.liveCount = 0;
          morph.geom.instanceCount = 0;
          
          const all = [];
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            const word = it.word || pickBlessingWord();
            const pts = sampleTextToPoints3D(word, Object.assign({
              fontSize: 160, 
              width: 2000,
              height: 500,
              step: 9, // Reduced density: step from 8 -> 9 (~20% density reduction)
              scale: 0.022, 
            }, it.config || {}));

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            for (let j = 0; j < pts.length; j++) {
              const p = pts[j];
              if (p.x < minX) minX = p.x;
              if (p.x > maxX) maxX = p.x;
              if (p.y < minY) minY = p.y;
              if (p.y > maxY) maxY = p.y;
            }
            const midX = (minX + maxX) / 2;
            all.push({
              it,
              pts,
              midX,
              box: {
                left: minX - midX,
                right: maxX - midX,
                bottom: minY,
                top: maxY,
              },
            });
          }

          let total = 0;
          for (let i = 0; i < all.length; i++) total += all[i].pts.length;
          const count = Math.min(morph.count, total);
          morph.liveCount = count;
          morph.geom.instanceCount = count;

          // Calculate group center to preserve relative layout
          let avgX = 0, avgY = 0;
          if (all.length > 0) {
            for (let bi = 0; bi < all.length; bi++) {
              avgX += all[bi].it.origin.x;
              avgY += all[bi].it.origin.y;
            }
            avgX /= all.length;
            avgY /= all.length;
          }

          let groupOffsetX = 0;
          let groupOffsetY = 0;
          
          // Check if absolute positioning is requested
          const useAbsolute = all.length > 0 && all[0].it.absolute;

          if (!useAbsolute) {
             // Random position: Ring distribution to avoid center
             // Radius 10.0 to 20.0 to ensure it is away from center (0, 2-4)
             const angle = Math.random() * Math.PI * 2;
             const radius = rand(10.0, 20.0); 
             const screenCX = 0;
             const screenCY = 0.0; // Lower center to favor bottom screen
             
             let targetCX = screenCX + Math.cos(angle) * radius;
             let targetCY = screenCY + Math.sin(angle) * radius * 0.65; 
             
             // Clamp to keep within visible bounds (Lower 2/3: approx -7 to 4)
             targetCX = clamp(targetCX, -15.0, 15.0);
             // User Request: Shift last two lines down by 0.5 char height
             // This affects general random positioning, but maybe we should adjust targetCY range?
             // Or apply global offset?
             // The user said "last two lines", referring to "诸位 2026新年快乐"
             // which is the Intro Text (HNY) or the ending text?
             // "最后两行‘诸位 2026新年快乐’" usually refers to the ENDING text in Stage 7.
             // This triggerBlessingTexts function is used for ALL text.
             // We should check if the text content matches "诸位" or "2026新年快乐" and apply offset.
             
             targetCY = clamp(targetCY, -6.0, 3.5);
   
             groupOffsetX = targetCX - avgX;
             groupOffsetY = targetCY - avgY;
          }

          const placed = [];
          for (let bi = 0; bi < all.length; bi++) {
            const origin = all[bi].it.origin;
            const word = all[bi].it.word;
            let extraOffsetY = 0;
            if (word && (word.includes("诸位") || word.includes("2026") || word.includes("新年快乐"))) {
              extraOffsetY = -2.5;
            }
            placed.push({
              x: origin.x + groupOffsetX,
              y: origin.y + groupOffsetY + extraOffsetY,
              z: origin.z,
              left: all[bi].box.left,
              right: all[bi].box.right,
              bottom: all[bi].box.bottom,
              top: all[bi].box.top,
            });
          }

          if (placed.length > 1) {
            const minGapX = 0.9;
            const minOverlapY = 0.35;
            const limitX = 17.0;
            for (let it = 0; it < 8; it++) {
              let moved = false;
              for (let i = 0; i < placed.length; i++) {
                for (let j = i + 1; j < placed.length; j++) {
                  const a = placed[i];
                  const b = placed[j];
                  const aMinY = a.y + a.bottom;
                  const aMaxY = a.y + a.top;
                  const bMinY = b.y + b.bottom;
                  const bMaxY = b.y + b.top;
                  const overlapY = Math.min(aMaxY, bMaxY) - Math.max(aMinY, bMinY);
                  if (overlapY <= minOverlapY) continue;

                  const aLeft = a.x + a.left;
                  const aRight = a.x + a.right;
                  const bLeft = b.x + b.left;
                  const bRight = b.x + b.right;

                  if (a.x <= b.x) {
                    const gap = bLeft - aRight;
                    if (gap < minGapX) {
                      const push = (minGapX - gap) * 0.5;
                      a.x = clamp(a.x - push, -limitX, limitX);
                      b.x = clamp(b.x + push, -limitX, limitX);
                      moved = true;
                    }
                  } else {
                    const gap = aLeft - bRight;
                    if (gap < minGapX) {
                      const push = (minGapX - gap) * 0.5;
                      a.x = clamp(a.x + push, -limitX, limitX);
                      b.x = clamp(b.x - push, -limitX, limitX);
                      moved = true;
                    }
                  }
                }
              }
              if (!moved) break;
            }
          }

          let cursor = 0;
          for (let bi = 0; bi < all.length; bi++) {
            const startPos = all[bi].it.startPos; 
            const midX = all[bi].midX;
            const pts = all[bi].pts;
            const baseX = placed[bi] ? placed[bi].x : all[bi].it.origin.x + groupOffsetX;
            const baseY = placed[bi] ? placed[bi].y : all[bi].it.origin.y + groupOffsetY;
            const baseZ = placed[bi] ? placed[bi].z : all[bi].it.origin.z;

            for (let i = 0; i < pts.length && cursor < count; i++, cursor++) {
              const p = pts[i];
              const b3 = cursor * 3;
              morph.target[b3 + 0] = baseX + (p.x - midX);
              morph.target[b3 + 1] = baseY + p.y;
              morph.target[b3 + 2] = baseZ + p.z;

              // Use source particles if available
              if (sourceParticles && sourceParticles.length > 0) {
                 const srcIdx = cursor % sourceParticles.length;
                 const src = sourceParticles[srcIdx];
                 
                 morph.pos[b3 + 0] = src.pos.x;
                 morph.pos[b3 + 1] = src.pos.y;
                 morph.pos[b3 + 2] = src.pos.z;
                 
                 // Inherit velocity for natural transition
                 morph.vel[b3 + 0] = src.vel.x;
                 morph.vel[b3 + 1] = src.vel.y;
                 morph.vel[b3 + 2] = src.vel.z;
                 
                 // Inherit color
                 morph.col[cursor * 4 + 0] = src.color.r;
                 morph.col[cursor * 4 + 1] = src.color.g;
                 morph.col[cursor * 4 + 2] = src.color.b;
                 morph.col[cursor * 4 + 3] = 1;
              } else {
                 // Fallback to random blast effect
                 if (startPos) {
                   morph.pos[b3 + 0] = startPos.x + rand(-18.0, 18.0);
                   morph.pos[b3 + 1] = startPos.y + rand(-18.0, 18.0);
                   morph.pos[b3 + 2] = startPos.z + rand(-18.0, 18.0);
                 } else {
                   morph.pos[b3 + 0] = morph.target[b3 + 0] + rand(-2.0, 2.0);
                   morph.pos[b3 + 1] = morph.target[b3 + 1] + rand(-2.0, 2.0);
                   morph.pos[b3 + 2] = morph.target[b3 + 2] + rand(-2.0, 2.0);
                 }
                 
                 const theta = Math.random() * Math.PI * 2;
                 const phi = Math.acos(2 * Math.random() - 1);
                 const speed = rand(2.0, 6.0);
                 morph.vel[b3 + 0] = speed * Math.sin(phi) * Math.cos(theta);
                 morph.vel[b3 + 1] = speed * Math.sin(phi) * Math.sin(theta);
                 morph.vel[b3 + 2] = speed * Math.cos(phi);
                 
                 morph.col[cursor * 4 + 0] = gold.r;
                 morph.col[cursor * 4 + 1] = gold.g;
                 morph.col[cursor * 4 + 2] = gold.b;
                 morph.col[cursor * 4 + 3] = 1;
              }

              morph.baseAlpha[cursor] = 0.30; // Reduced brightness (was 0.45)
              morph.baseWidth[cursor] = 0.025; // Reduced width (was 0.035)
              morph.alpha[cursor] = morph.baseAlpha[cursor];
              morph.width[cursor] = 0.025;
              morph.delay[cursor] = all[bi].it.delay || 0; // Use item delay for staggered start

              morph.head[b3 + 0] = morph.pos[b3 + 0];
              morph.head[b3 + 1] = morph.pos[b3 + 1];
              morph.head[b3 + 2] = morph.pos[b3 + 2];
              morph.tail[b3 + 0] = morph.pos[b3 + 0];
              morph.tail[b3 + 1] = morph.pos[b3 + 1];
              morph.tail[b3 + 2] = morph.pos[b3 + 2];
            }
          }
          
          // Force full reveal for Blessing Stages to ensure visibility
          if (isBlessingStage()) {
             morph.reveal3.set(999, 999, 999);
             // Ensure gravity dissolve is off
             morph.gravityDissolve = false;
          }
          
          morph.geom.attributes.iHead.needsUpdate = true;
          morph.geom.attributes.iTail.needsUpdate = true;
          morph.geom.attributes.iColor.needsUpdate = true;
          morph.geom.attributes.iAlpha.needsUpdate = true;
          morph.geom.attributes.iWidth.needsUpdate = true;
          
          // Clear any old timers
          if (stageState._blessingTimers) {
             stageState._blessingTimers.forEach(t => clearTimeout(t));
             stageState._blessingTimers = [];
          }
        }

        function captureActiveParticles(maxCount = 5000) {
          if (!particles || !particles.alive) return [];
          const res = [];
          for(let i=0; i<particles.count; i++) {
             if (particles.alive[i] && particles.kind[i] === 1) { // 1=Explosion particle
                const b = i * 3;
                res.push({
                   pos: { x: particles.pos[b+0], y: particles.pos[b+1], z: particles.pos[b+2] },
                   vel: { x: particles.vel[b+0], y: particles.vel[b+1], z: particles.vel[b+2] },
                   color: { r: particles.col[i*4+0], g: particles.col[i*4+1], b: particles.col[i*4+2] }
                });
                if (res.length >= maxCount) break;
             }
          }
          return res;
        }

        function killActiveParticles() {
           if (!particles || !particles.alive) return;
           for(let i=0; i<particles.count; i++) {
              if (particles.alive[i] && particles.kind[i] === 1) {
                 particles.kill(i);
              }
           }
        }

        const _explodeNdc = new THREE.Vector3();
        const _explodeCenter = new THREE.Vector3();
        const _explodeTmp = new THREE.Vector3();

        function fitExplosionToViewport(ep, margin = 0.96) {
          if (!camera) return ep;
          camera.updateMatrixWorld(true);
          const center = controls ? controls.target : _explodeCenter.set(0, 0, 0);
          let cx = center.x, cy = center.y, cz = center.z;
          if (stageState.stage === 4 || stageState.stage === 7) {
            cx += CONFIG.fireworks.biasX || 0;
            cy += CONFIG.fireworks.biasY || 0;
            cz += CONFIG.fireworks.biasZ || 0;
          }
          _explodeCenter.set(cx, cy, cz);
          for (let i = 0; i < 12; i++) {
            _explodeNdc.copy(ep).project(camera);
            const overX = Math.abs(_explodeNdc.x) > margin;
            const overY = Math.abs(_explodeNdc.y) > margin;
            const overZ = _explodeNdc.z < -1 || _explodeNdc.z > 1;
            if (!overX && !overY && !overZ) break;
            ep.lerp(_explodeCenter, 0.35);
          }
          return ep;
        }

        function nowMs() {
          try {
            return performance && typeof performance.now === "function" ? performance.now() : Date.now();
          } catch {
            return Date.now();
          }
        }

        function explodeAt(p, baseColor, power, count, isGiant = false, hasSecondary = false, playSound = true, fitToViewport = true, soundType = null) {
          const c = baseColor || pickNeonColor();
          // 如果是巨型烟花，增强爆炸力度和粒子数量
          // 范围扩大20% (finalPower * 1.2)
          const finalPower = (isGiant ? power * 1.8 : power) * 1.2;
          const finalCount = isGiant 
            ? Math.floor((count || randInt(CONFIG.fireworks.rocketBurstMin, CONFIG.fireworks.rocketBurstMax)) * 1.5)
            : (count || randInt(CONFIG.fireworks.rocketBurstMin, CONFIG.fireworks.rocketBurstMax));
            
          const ep = new THREE.Vector3(clamp(p.x, -80.0, 80.0), clamp(p.y, -80.0, 80.0), clamp(p.z, -80.0, 80.0));
          if (fitToViewport) fitExplosionToViewport(ep);
          if (camera) {
            _explodeTmp.copy(ep).sub(camera.position);
            const d = _explodeTmp.length();
            if (d > 1e-6 && d < 25.0) {
              _explodeTmp.multiplyScalar(30.0 / d);
              ep.copy(camera.position).add(_explodeTmp);
            } else if (d <= 1e-6) {
              ep.set(camera.position.x, camera.position.y, camera.position.z - 30.0);
            }
          }
          const lastExplodePos = stageState._lastExplodePos || (stageState._lastExplodePos = new THREE.Vector3());
          lastExplodePos.copy(ep);
          stageState._lastExplodeAt = clock ? clock.elapsedTime : 0;

          // Sound Trigger (New SoundManager)
          if (playSound && typeof soundManager !== 'undefined') {
             // Determine Type
             let type = soundType;
             let vol = 0.35;
             let pitch = rand(0.95, 1.15);

             // Auto-infer if not specified (Default Stage 4 Logic)
             if (!type) {
                // If Stage 7, do NOT play unless explicitly requested (soundType passed)
                // Actually, user said "Super Giant every one adjusted individually".
                // So if soundType is null in Stage 7, we should probably be silent?
                // But let's keep backward compatibility for non-specified calls in other stages.
                if (stageState.stage === 7) {
                   // Silent if not specified in Stage 7
                   type = null; 
                } else if (stageState.stage === 4) {
                   // Stage 4 Normal Fireworks:
                   // Logic: 
                   // < 15000 particles: 90% chance for signal
                   // > 15000 particles: Silent (only climax)
                   const count = stageState._aliveCount || 0;
                   if (count < 15000) {
                       if (Math.random() < 0.9) {
                          type = 'singal';
                       } else {
                          type = null; 
                       }
                   } else {
                       // > 15000: Silent
                       type = null;
                   }
                } else {
                   // Stage 4 / Others: Default Logic
                   if (isGiant || finalCount >= 1000 || finalPower >= 40) {
                      type = 'giant';
                      vol = 0.85;
                      pitch = rand(0.8, 1.0);
                   } else if (finalCount >= 280 || finalPower >= 18) {
                      type = 'medium'; 
                      vol = 0.65;
                      pitch = rand(1.2, 1.4);
                   } else {
                      type = 'singal';
                   }
                }
             } else {
                // Manual override parameters based on type
                // But wait, if Stage 4 > 15000, we should silence EVERYTHING except climax.
                // The global filter in soundManager.play handles this for > 15000.
                // But for < 15000, we should respect the type if passed?
                // User said "signal randomly 50%".
                // If soundType is passed (e.g. from a giant firework logic), should we silence it?
                // "15000以下... signal随机给50%的烟花".
                // This usually implies normal logic.
                // If giant fireworks pass explicit types, maybe we should let them be?
                // Or does "remove all sound effects" mean EVERYTHING?
                // "去掉普通烟花的全部音效，然后重做"
                // Let's assume if explicit type is passed in Stage 4 < 15000, it's special and allowed (subject to 50%?? No, user said signal for 50%).
                // Actually, explodeAt is called for all fireworks.
                // If we want to strictly follow "signal random 50%", we should probably override even explicit types in Stage 4 < 15000 if they are 'singal'/'medium'/'giant'?
                // But usually explicit types are for specific choreography.
                // Let's stick to the "auto-infer" block for the general population.
                
                if (type === 'giant') {
                   vol = 0.85;
                   pitch = rand(0.8, 1.0);
                } else if (type === 'medium') {
                   vol = 0.65;
                   pitch = rand(1.2, 1.4);
                }
             }

             if (type) {
                // 2. Play with Random Spread (0-80ms)
                soundManager.play(type, { 
                   volume: vol, 
                   pitch: pitch, 
                   delay: randInt(0, 80),
                   force: true 
                });
             }

             // 3. Schedule Secondary Crackle
             // Only auto-play secondary if NOT stage 7 (Stage 7 handles manually)
             // OR if we want to keep it simple. User said:
             // "G1... secondary after 3rd"
             // "G2... secondary no gap"
             // It seems safer to disable auto-secondary for Stage 7 and handle it manually too.
             if (hasSecondary && stageState.stage !== 7) {
                // Delay matches the particle visual delay (0.34s - 0.82s)
                soundManager.play('secondary', {
                   volume: 0.5,
                   delay: randInt(400, 800),
                   force: true
                });
             }
          }

          // 如果是巨型烟花，允许更大的爆炸边缘判断，以保持力度
          const edgeDiv = isGiant ? 16.0 : 10.0;
          const edge = Math.max(Math.abs(ep.x) / edgeDiv, Math.max(Math.abs(ep.z + 1.6) / 6.0, Math.max(0, (ep.y - 6.7) / 2.0)));
          const powK = finalPower * lerp(1.0, 0.72, clamp(edge, 0, 1));
          const s = CONFIG.fireworks.speedScale || 1;
          if (!stageState._firstExplodeLogged) {
            stageState._firstExplodeLogged = true;
            DEBUG.log("explodeAt", { n: finalCount, p: { x: ep.x, y: ep.y, z: ep.z }, edge });
          }
          const dir = new THREE.Vector3();
          for (let i = 0; i < finalCount; i++) {
            const u = Math.random() * 2 - 1;
            const th = Math.random() * Math.PI * 2;
            const s2 = Math.sqrt(Math.max(0, 1 - u * u));
            dir.set(s2 * Math.cos(th), u, s2 * Math.sin(th));
            
            // 检查是否过于密集（简化版：如果粒子总数过多，增加扩散范围）
            const spreadFactor = particles.count > 10000 ? 1.2 : 1.0;
            
            // 速度也呈现高斯分布特征
            const speedFactor = (Math.random() + Math.random() + Math.random()) / 3.0; // 趋向于0.5
            const sp = rand(powK * 0.4, powK * 1.2) * (0.5 + speedFactor) * spreadFactor;
            
            _explodeTmp.copy(dir);
            const vel = _explodeTmp.multiplyScalar(sp);
            vel.y += rand(-0.85, 0.25);
            // 消散时间减少80%
            let life = rand(0.75, 1.45) / s * 0.2;
            if (stageState.stage === 7 && isGiant) life *= 2.0; // 超级巨型烟花粒子寿命延长

            const cc = c.clone().offsetHSL(rand(-0.02, 0.02), rand(-0.04, 0.08), rand(-0.05, 0.05));
            // 巨型烟花使用 kind=3 (更长尾迹)
          const idx = particles.spawnParticle(ep, vel, cc, life, isGiant ? 3 : 1);
          if (idx !== -1 && hasSecondary) {
            const g = hasSecondary === 2 ? 2 : 1;
            particles.iGroup[idx] = g;
            if (g === 2) particles.iDelay[idx] = rand(0.34, 0.82);
          }
        }
      }

        function explodeSecondary(p, baseColor) {
           const power = 0.84; // 再次减缓30% (was 1.2)
           const count = 12;
           const ep = p.clone();
           
           const dir = new THREE.Vector3();
           for(let i=0; i<count; i++) {
              const u = Math.random() * 2 - 1;
              const th = Math.random() * Math.PI * 2;
              const s2 = Math.sqrt(Math.max(0, 1 - u * u));
              dir.set(s2 * Math.cos(th), u, s2 * Math.sin(th));
              
              const sp = rand(power * 0.5, power * 1.5); 
              const vel = dir.multiplyScalar(sp);
              
              // 延长寿命：确保最后消失 (1.5s - 2.4s)
              // 针对非超级烟花(非Stage 7)，寿命增加40% (0.48 * 1.4 = 0.672)
              let life = rand(1.5, 2.4);
              if (stageState.stage !== 7) life *= 0.67;
              
              const cc = baseColor.clone();
              
              // Use kind=7 for secondary particles (slender tail)
              particles.spawnParticle(ep, vel, cc, life, 7);
           }
        }

        function pushWordsFromLine(dt, intensity, headPos, tailPos) {
          const sprites = wordState.sprites;
          const vel = wordState.vel;
          const alive = wordState.alive;
          const lineDir = new THREE.Vector3().subVectors(headPos, tailPos);
          const lineLen = lineDir.length() + 1e-6;
          lineDir.multiplyScalar(1 / lineLen);
          const tmp = new THREE.Vector3();
          const closest = new THREE.Vector3();
          for (let i = 0; i < sprites.length; i++) {
            if (!alive[i]) continue;
            const p = sprites[i].position;
            tmp.subVectors(p, tailPos);
            const t = clamp(tmp.dot(lineDir), 0, lineLen);
            closest.copy(tailPos).addScaledVector(lineDir, t);
            const d = p.distanceTo(closest);
            const fall = Math.exp(-d * d * 0.75);
            if (fall < 0.02) continue;
            const push = tmp.subVectors(p, closest).normalize().multiplyScalar(intensity * fall);
            vel[i].addScaledVector(push, dt);
          }
        }

        function repelWordsField(dt, center, radius, strength) {
          const sprites = wordState.sprites;
          const vel = wordState.vel;
          const alive = wordState.alive;
          const r2 = radius * radius;
          for (let i = 0; i < sprites.length; i++) {
            if (!alive[i]) continue;
            const p = sprites[i].position;
            const dx = p.x - center.x;
            const dy = p.y - center.y;
            const dz = p.z - center.z;
            const d2 = dx * dx + dy * dy + dz * dz;
            if (d2 > r2) continue;
            const d = Math.sqrt(Math.max(1e-6, d2));
            const fall = (1.0 - d / radius) ** 2;
            const k = (strength * fall) / d;
            vel[i].x += dx * k * dt;
            vel[i].y += dy * k * dt;
            vel[i].z += dz * (k * 0.85) * dt;
          }
        }

        function blastWordsOut(center) {
          const sprites = wordState.sprites;
          const vel = wordState.vel;
          const alpha = wordState.alpha;
          const alive = wordState.alive;
          const mode = wordState.mode;
          const blastAge = wordState.blastAge;
          const blastLife = wordState.blastLife;
          const c = center ? center.clone() : new THREE.Vector3(0, 2.2, 0);
          wordState.blastCenter.copy(c);
          wordState.blastActive = 1;
          wordState.blastT = 0;
          
          for (let i = 0; i < sprites.length; i++) {
            if (!alive[i]) continue;
            
            // 仅切换状态，让updateWords处理平滑的波动效果
            // alpha[i] = 1;
            mode[i] = 1; // 设置为爆炸模式
            blastAge[i] = 0;
            blastLife[i] = rand(3.0, 5.0); // 延长时间确保飞出屏幕
            sprites[i].visible = true;
            
            // 极轻微的扰动，打破静止感
            vel[i].x += rand(-0.1, 0.1);
            vel[i].y += rand(-0.1, 0.1);
            vel[i].z += rand(-0.1, 0.1);
          }
        }

        const morph = {
          active: false,
          fadeIn: 0,
          count: 200000,
          liveCount: 0,
          useDots: true,
          locked: false,
          frozen: false,
          windActive: false,
          windT: 0,
          pos: new Float32Array(200000 * 3),
          vel: new Float32Array(200000 * 3),
          target: new Float32Array(200000 * 3),
          col: new Float32Array(200000 * 4),
          alpha: new Float32Array(200000),
          width: new Float32Array(200000),
          baseAlpha: new Float32Array(200000),
          baseWidth: new Float32Array(200000),
          breathePhase: new Float32Array(200000),
          breatheSpeed: new Float32Array(200000),
          breatheAmpA: new Float32Array(200000),
          breatheAmpW: new Float32Array(200000),
          delay: new Float32Array(200000),
          group: new Float32Array(200000),
          head: new Float32Array(200000 * 3),
          tail: new Float32Array(200000 * 3),
          mesh: null,
          geom: null,
          mat: null,
          dotMesh: null,
          dotMat: null,
          t: 0,
          phase: 0,
          phaseT: 0,
          reveal3: new THREE.Vector3(0, 0, 0),
        };

        function initMorphSystem() {
          const base = new THREE.PlaneGeometry(1, 1, 1, 1);
          const g = new THREE.InstancedBufferGeometry();
          g.index = base.index;
          g.attributes.position = base.attributes.position;
          g.attributes.uv = base.attributes.uv;
          g.instanceCount = 0;
          g.setAttribute("iHead", new THREE.InstancedBufferAttribute(morph.head, 3));
          g.setAttribute("iTail", new THREE.InstancedBufferAttribute(morph.tail, 3));
          g.setAttribute("iColor", new THREE.InstancedBufferAttribute(morph.col, 4));
          g.setAttribute("iAlpha", new THREE.InstancedBufferAttribute(morph.alpha, 1));
          g.setAttribute("iWidth", new THREE.InstancedBufferAttribute(morph.width, 1));
          g.setAttribute("iDelay", new THREE.InstancedBufferAttribute(morph.delay, 1));
          g.setAttribute("iGroup", new THREE.InstancedBufferAttribute(morph.group, 1));
          const m = new THREE.ShaderMaterial({
            vertexShader: TrailShaders.vertex,
            fragmentShader: TrailShaders.fragment,
            transparent: true,
            depthWrite: false,
            depthTest: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            uniforms: {
              uTime: { value: 0 },
              uReveal3: { value: new THREE.Vector3(0, 0, 0) },
              uFlickerStrength: { value: 0.0 },
              uSweepStrength: { value: 0.0 },
              uBillboardRot: { value: new THREE.Matrix3() },
              uBillboardPivot: { value: new THREE.Vector3() },
            },
          });
          const dotM = new THREE.ShaderMaterial({
            vertexShader: DotShaders.vertex,
            fragmentShader: DotShaders.fragment,
            transparent: true,
            depthWrite: false,
            depthTest: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            uniforms: {
              uTime: { value: 0 },
              uReveal3: { value: new THREE.Vector3(0, 0, 0) },
              uBillboardRot: { value: new THREE.Matrix3() },
              uBillboardPivot: { value: new THREE.Vector3() },
              uSparkleStrength: { value: 0.0 },
              uScanStrength: { value: 0.0 },
            },
          });
          morph.geom = g;
          morph.mat = m;
          morph.mesh = new THREE.Mesh(g, m);
          morph.mesh.frustumCulled = false;
          scene.add(morph.mesh);
          morph.dotMat = dotM;
          morph.dotMesh = new THREE.Mesh(g, dotM);
          morph.dotMesh.frustumCulled = false;
          scene.add(morph.dotMesh);

          morph.liveCount = 0;
          morph.mesh.visible = false;
          morph.dotMesh.visible = false;
        }

        initMorphSystem();

        const _morphBillboardPivot = new THREE.Vector3();
        const _morphBillboardUp = new THREE.Vector3(0, 1, 0);
        const _morphBillboardM4 = new THREE.Matrix4();
        const _morphBillboardM3 = new THREE.Matrix3();
        const _morphBillboardX = new THREE.Vector3();
        const _morphBillboardY = new THREE.Vector3();
        const _morphBillboardZ = new THREE.Vector3();

        function updateMorphBillboard() {
          if (!morph.active || !morph.mat || !morph.dotMat) return;

          const enabled = stageState.stage === 6 || stageState.stage === 7 || stageState.stage === 25;
          if (!enabled) {
            morph.mat.uniforms.uBillboardRot.value.identity();
            morph.dotMat.uniforms.uBillboardRot.value.identity();
            morph.mat.uniforms.uBillboardPivot.value.set(0, 0, 0);
            morph.dotMat.uniforms.uBillboardPivot.value.set(0, 0, 0);
            return;
          }

          _morphBillboardPivot.set(0, 2.0, 0.5);

          camera.updateMatrixWorld(true);
          _morphBillboardZ.copy(camera.position).sub(_morphBillboardPivot);
          const zLen2 = _morphBillboardZ.lengthSq();
          if (zLen2 < 1e-10) return;
          _morphBillboardZ.multiplyScalar(1 / Math.sqrt(zLen2));

          _morphBillboardX.crossVectors(_morphBillboardUp, _morphBillboardZ);
          const xLen2 = _morphBillboardX.lengthSq();
          if (xLen2 < 1e-10) {
            _morphBillboardX.set(1, 0, 0);
          } else {
            _morphBillboardX.multiplyScalar(1 / Math.sqrt(xLen2));
          }

          _morphBillboardY.crossVectors(_morphBillboardZ, _morphBillboardX).normalize();

          _morphBillboardM4.makeBasis(_morphBillboardX, _morphBillboardY, _morphBillboardZ);
          _morphBillboardM3.setFromMatrix4(_morphBillboardM4);

          morph.mat.uniforms.uBillboardRot.value.copy(_morphBillboardM3);
          morph.dotMat.uniforms.uBillboardRot.value.copy(_morphBillboardM3);
          morph.mat.uniforms.uBillboardPivot.value.copy(_morphBillboardPivot);
          morph.dotMat.uniforms.uBillboardPivot.value.copy(_morphBillboardPivot);
        }

        function sampleTextToPoints3D(text, config) {
          const fontSize = config.fontSize || 140;
          const width = config.width || 1280;
          const height = config.height || 320;
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, width, height);
          
          // 增强文字渲染质量
          ctx.font = `bold ${fontSize}px "Comic Sans MS","PingFang SC","Microsoft YaHei",sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#fff";
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          ctx.fillText(text, width * 0.5, height * 0.5);
          
          const img = ctx.getImageData(0, 0, width, height);
          const data = img.data;
          const step = config.step || 3; // 更密集的采样
          const points = [];
          const scale = config.scale || 0.018;
          
          // 边缘检测增强 - 只采样文字边缘和内部高密度区域
          for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
              const idx = (y * width + x) * 4;
              if (data[idx + 3] > 128) { // 更高的透明度阈值确保清晰轮廓
                const px = (x - width * 0.5) * scale;
                const py = (height * 0.5 - y) * scale;
                
                // 增强的3D深度效果：中心区域深度小，边缘深度大
                const distFromCenter = Math.sqrt(
                  Math.pow((x - width * 0.5) / (width * 0.5), 2) + 
                  Math.pow((y - height * 0.5) / (height * 0.5), 2)
                );
                
                // 基于位置的深度变化，创造立体感
                const depthScale = 0.2 + distFromCenter * 0.3;
                const pz = (Math.random() * 2 - 1) * depthScale;
                
                // 添加微小的随机偏移，避免过于规整
                const jitter = 0.02;
                const finalX = px + (Math.random() - 0.5) * jitter;
                const finalY = py + (Math.random() - 0.5) * jitter;
                
                points.push(new THREE.Vector3(finalX, finalY, pz));
              }
            }
          }
          
          return points;
        }

        function assignFinaleTextTargetsNew() {
          const lines = CONFIG.finaleText.lines || ["My Friend", "2026 新年快乐"];
          const scale = 0.015;
          // 间距大幅增加至15.0，确保文字完全不重叠
          const gap = (CONFIG.finaleText && CONFIG.finaleText.lineGap) || 15.0;
          const fontSize = 234;
          const isZhuWeiFinale = (lines || []).some((s) => String(s || "").includes("诸位"));
          const finaleDownShiftY = isZhuWeiFinale ? -0.5 * fontSize * scale : 0;
          const lineCount = Math.min(3, (lines || []).length);
          const yOffsets =
            lineCount <= 1 ? [0.0] : lineCount === 2 ? [gap * 0.5, -gap * 0.5] : [gap, 0.0, -gap];

          const gold = new THREE.Color("#ffcc66");
          let allPoints = [];

          for (let i = 0; i < Math.min(3, lines.length); i++) {
            let pts = sampleTextToPoints3D(lines[i], {
              // 字体再增大30% (180 -> 234, 2400 -> 3120, 480 -> 624)
              fontSize: fontSize,
              width: 3120,
              height: 624,
              step: 2,
              scale: scale,
            });

            // Reduce by another 20% from 0.38 -> ~0.30 (User Request)
            pts = pts.filter(() => Math.random() < 0.30);

            const yOff = yOffsets[i] || 0;
            let minX = Infinity;
            let maxX = -Infinity;
            for (let p of pts) {
              if (p.x < minX) minX = p.x;
              if (p.x > maxX) maxX = p.x;
            }
            const xRange = Math.max(0.1, maxX - minX);
            const xCenter = (minX + maxX) * 0.5;

            for (let p of pts) {
              p.x -= xCenter;
              p.y += 4.0 + yOff + finaleDownShiftY;
              p.z += 0.5;
              p._lineIdx = i;
              p._normalizedX = (p.x + xRange * 0.5) / xRange;
            }
            allPoints = allPoints.concat(pts);
          }

          const count = Math.min(morph.count, allPoints.length);
          morph.liveCount = count;
          morph.geom.instanceCount = count;
          const baseWidth = 0.0125;
          const baseAlpha = 0.98;
          for (let i = 0; i < count; i++) {
            const p = allPoints[i];
            const b3 = i * 3;
            morph.target[b3 + 0] = p.x;
            morph.target[b3 + 1] = p.y;
            morph.target[b3 + 2] = p.z;
            morph.col[i * 4 + 0] = gold.r;
            morph.col[i * 4 + 1] = gold.g;
            morph.col[i * 4 + 2] = gold.b;
            morph.col[i * 4 + 3] = 1;
            morph.baseAlpha[i] = baseAlpha;
            morph.baseWidth[i] = baseWidth;
            morph.alpha[i] = baseAlpha;
            morph.width[i] = baseWidth;
            morph.group[i] = p._lineIdx % 3;
            morph.delay[i] = rand(0.0, 0.06);
            morph.breathePhase[i] = rand(0, Math.PI * 2);
            morph.breatheSpeed[i] = rand(0.65, 1.85);
            morph.breatheAmpA[i] = rand(0.85, 0.98); // Stronger light/dark contrast (almost full blink)
            morph.breatheAmpW[i] = rand(0.40, 0.65); // Stronger width variation
          }

          morph.geom.attributes.iHead.needsUpdate = true;
          morph.geom.attributes.iTail.needsUpdate = true;
          morph.geom.attributes.iColor.needsUpdate = true;
          morph.geom.attributes.iAlpha.needsUpdate = true;
          morph.geom.attributes.iWidth.needsUpdate = true;
          morph.geom.attributes.iDelay.needsUpdate = true;
          morph.geom.attributes.iGroup.needsUpdate = true;
          
          // Sync uniforms
          if (morph.mat) {
             morph.mat.uniforms.uTime.value = clock.elapsedTime;
             morph.mat.uniforms.uReveal3.value.copy(morph.reveal3);
          }
          if (morph.dotMat) {
             morph.dotMat.uniforms.uTime.value = clock.elapsedTime;
             morph.dotMat.uniforms.uReveal3.value.copy(morph.reveal3);
          }
        }



        function updateMorph(dt, t) {
          if (!morph.active) {
             if (morph.mesh && morph.mesh.visible) morph.mesh.visible = false;
             if (morph.dotMesh && morph.dotMesh.visible) morph.dotMesh.visible = false;
             return;
          }
          morph.mat.uniforms.uTime.value = t;
          morph.mat.uniforms.uReveal3.value.copy(morph.reveal3);
          morph.dotMat.uniforms.uTime.value = t;
          morph.dotMat.uniforms.uReveal3.value.copy(morph.reveal3);
          
          const useDots = morph.phase === 3;
          morph.mesh.visible = !useDots;
          morph.dotMesh.visible = useDots;

          if (morph.frozen) return;

          if (morph.gravityDissolve) {
             morph.windT += dt;
             const t = morph.windT;
             const duration = 2.5;
             const p = t / duration;
             
             if (p >= 1.0) {
                morph.liveCount = 0;
                morph.mesh.visible = false;
                morph.dotMesh.visible = false;
                morph.gravityDissolve = false;
                return;
             }
             
             const n = morph.liveCount || 0;
             const alphaScale = 1.0 - p;
             
             for (let i = 0; i < n; i++) {
                const b3 = i * 3;
                
                // Gravity
                morph.vel[b3+1] -= 2.0 * dt; // Gravity
                
                // Drag
                morph.vel[b3+0] *= 0.98;
                morph.vel[b3+1] *= 0.98;
                morph.vel[b3+2] *= 0.98;
                
                morph.pos[b3+0] += morph.vel[b3+0] * dt;
                morph.pos[b3+1] += morph.vel[b3+1] * dt;
                morph.pos[b3+2] += morph.vel[b3+2] * dt;
                
                // Update Head/Tail
                const vx = morph.vel[b3+0];
                const vy = morph.vel[b3+1];
                const vz = morph.vel[b3+2];
                const sp = Math.sqrt(vx*vx + vy*vy + vz*vz) + 1e-6;
                const nx = vx / sp;
                const ny = vy / sp;
                const nz = vz / sp;
                
                const tailLen = 0.15;
                morph.head[b3+0] = morph.pos[b3+0];
                morph.head[b3+1] = morph.pos[b3+1];
                morph.head[b3+2] = morph.pos[b3+2];
                morph.tail[b3+0] = morph.pos[b3+0] - nx * tailLen;
                morph.tail[b3+1] = morph.pos[b3+1] - ny * tailLen;
                morph.tail[b3+2] = morph.pos[b3+2] - nz * tailLen;
                
                morph.alpha[i] = morph.baseAlpha[i] * alphaScale;
                morph.width[i] = morph.baseWidth[i] * alphaScale;
             }
             morph.geom.attributes.iAlpha.needsUpdate = true;
             morph.geom.attributes.iWidth.needsUpdate = true;
             morph.geom.attributes.iHead.needsUpdate = true;
             morph.geom.attributes.iTail.needsUpdate = true;
             return;
          }

          morph.fadeIn = Math.min(1, morph.fadeIn + dt * 0.85);
          const fade = morph.fadeIn * morph.fadeIn * (3 - 2 * morph.fadeIn);
          const tailLen = morph.phase === 3 ? 0.018 : 0.27;
          const n = morph.liveCount || 0;

          if (morph.windActive) {
            morph.windT += dt;
            const windT = morph.windT;
            const n = morph.liveCount || 0;
            const duration = 1.2; // Flight duration per particle
            const windAlphaScale = morph.windAlphaScale == null ? 1 : morph.windAlphaScale;
            
            for (let i = 0; i < n; i++) {
              const b3 = i * 3;
              const delay = morph.delay[i];
              const t = windT - delay;

              if (t <= 0) {
                 // Hold Position
                 morph.pos[b3+0] = morph.target[b3+0];
                 morph.pos[b3+1] = morph.target[b3+1];
                 morph.pos[b3+2] = morph.target[b3+2];
                 morph.alpha[i] = windAlphaScale * (morph.baseAlpha[i] || 1);
                 morph.width[i] = morph.baseWidth[i];
                 
                 // Update Head/Tail to avoid invisible zero-area quads
                 morph.head[b3+0] = morph.pos[b3+0];
                 morph.head[b3+1] = morph.pos[b3+1];
                 morph.head[b3+2] = morph.pos[b3+2];
                 // Add tiny offset to tail to ensure non-zero area for visibility
                 morph.tail[b3+0] = morph.pos[b3+0] + 0.05;
                 morph.tail[b3+1] = morph.pos[b3+1];
                 morph.tail[b3+2] = morph.pos[b3+2];
              } else {
                 // Dissipate
                 let p = t / duration;
                 if (p > 1) p = 1;
                 
                 const startX = morph.target[b3+0];
                 const startY = morph.target[b3+1];
                 const startZ = morph.target[b3+2];
                 const endX = morph.vel[b3+0];
                 const endY = morph.vel[b3+1];
                 const endZ = morph.vel[b3+2];
                 
                 // Quadratic ease out for explosion feel
                 const pp = 1 - (1-p)*(1-p);
                 
                 const curX = startX + (endX - startX) * pp;
                 const curY = startY + (endY - startY) * pp;
                 const curZ = startZ + (endZ - startZ) * pp;
                 
                 morph.pos[b3+0] = curX;
                 morph.pos[b3+1] = curY;
                 morph.pos[b3+2] = curZ;
                 
                 morph.alpha[i] = windAlphaScale * (morph.baseAlpha[i] || 1) * (1.0 - p);
                 morph.width[i] = morph.baseWidth[i] * (1.0 - p * 0.5);
                 
                 // Update Head/Tail for streak effect
                 // Velocity direction
                 const dx = endX - startX;
                 const dy = endY - startY;
                 const dz = endZ - startZ;
                 // Normalize
                 const len = Math.sqrt(dx*dx + dy*dy + dz*dz) + 1e-6;
                 const nx = dx / len;
                 const ny = dy / len;
                 const nz = dz / len;
                 
                 // Tail length
                 const tailLen = 0.3; 
                 morph.head[b3+0] = curX;
                 morph.head[b3+1] = curY;
                 morph.head[b3+2] = curZ;
                 morph.tail[b3+0] = curX - nx * tailLen;
                 morph.tail[b3+1] = curY - ny * tailLen;
                 morph.tail[b3+2] = curZ - nz * tailLen;
              }
            }
            morph.geom.attributes.iAlpha.needsUpdate = true;
            morph.geom.attributes.iWidth.needsUpdate = true;
            morph.geom.attributes.iHead.needsUpdate = true;
            morph.geom.attributes.iTail.needsUpdate = true;
          } else {
            // Slower physics for visible convergence
            // User requested faster convergence: increased spring, adjusted damping
            const baseSpring = stageState.stage === 6 ? 12.0 : 18.0; 
            const damping = stageState.stage === 6 ? 0.84 : 0.88;   

            for (let i = 0; i < n; i++) {
              if (isBlessingStage()) {
                 // Check delay for staggered start in Blessing Stages
                 if (morph.delay[i] > 0) {
                    morph.delay[i] -= dt;
                    if (morph.delay[i] > 0) {
                       // Debris behavior: Move with velocity, apply drag
                       const b3 = i * 3;
                       // Drag
                       morph.vel[b3+0] *= 0.92;
                       morph.vel[b3+1] *= 0.92;
                       morph.vel[b3+2] *= 0.92;
                       
                       // Move
                       morph.pos[b3+0] += morph.vel[b3+0] * dt;
                       morph.pos[b3+1] += morph.vel[b3+1] * dt;
                       morph.pos[b3+2] += morph.vel[b3+2] * dt;
                       
                       // Update tail for visibility
                       const vx = morph.vel[b3+0];
                       const vy = morph.vel[b3+1];
                       const vz = morph.vel[b3+2];
                       const sp = Math.sqrt(vx*vx + vy*vy + vz*vz) + 1e-6;
                       const nx = vx / sp;
                       const ny = vy / sp;
                       const nz = vz / sp;
                       
                       const debrisTail = Math.min(sp * 0.15, 0.6);
                       morph.head[b3+0] = morph.pos[b3+0];
                       morph.head[b3+1] = morph.pos[b3+1];
                       morph.head[b3+2] = morph.pos[b3+2];
                       morph.tail[b3+0] = morph.pos[b3+0] - nx * debrisTail;
                       morph.tail[b3+1] = morph.pos[b3+1] - ny * debrisTail;
                       morph.tail[b3+2] = morph.pos[b3+2] - nz * debrisTail;
                       
                       // Ensure visible
                       morph.alpha[i] = morph.baseAlpha[i];
                       morph.width[i] = morph.baseWidth[i];
                       
                       continue;
                    }
                 }
              }

            const b3 = i * 3;
            let px = morph.pos[b3 + 0];
            let py = morph.pos[b3 + 1];
            let pz = morph.pos[b3 + 2];
            let vx = morph.vel[b3 + 0];
            let vy = morph.vel[b3 + 1];
            let vz = morph.vel[b3 + 2];

            const tx = morph.target[b3 + 0];
            const ty = morph.target[b3 + 1];
            const tz = morph.target[b3 + 2];
            const dx = tx - px;
            const dy = ty - py;
            const dz = tz - pz;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            let appear = 1.0;
            if (stageState.stage === 6) {
              const g = morph.group[i] || 0;
              const groupReveal = g < 0.5 ? morph.reveal3.x : g > 1.5 ? morph.reveal3.z : morph.reveal3.y;
              const d = groupReveal - morph.delay[i];
              if (d <= 0) {
                morph.alpha[i] = 0;
                morph.width[i] = 0;
                morph.geom.attributes.iAlpha.needsUpdate = true;
                morph.geom.attributes.iWidth.needsUpdate = true;
                continue;
              }
              appear = clamp(d * 6.0, 0, 1);
            }

            const spring = baseSpring * (stageState.stage === 6 ? (0.22 + 0.78 * appear) : 1.0);

            vx += dx * spring * dt;
            vy += dy * spring * dt;
            vz += dz * spring * dt;
            vx *= damping;
            vy *= damping;
            vz *= damping;
            px += vx * dt;
            py += vy * dt;
            pz += vz * dt;

            morph.pos[b3 + 0] = px;
            morph.pos[b3 + 1] = py;
            morph.pos[b3 + 2] = pz;
            morph.vel[b3 + 0] = vx;
            morph.vel[b3 + 1] = vy;
            morph.vel[b3 + 2] = vz;

            const sp = Math.sqrt(vx * vx + vy * vy + vz * vz) + 1e-6;
            const inv = 1.0 / sp;
            const nx = vx * inv;
            const ny = vy * inv;
            const nz = vz * inv;
            morph.head[b3 + 0] = px;
            morph.head[b3 + 1] = py;
            morph.head[b3 + 2] = pz;
            morph.tail[b3 + 0] = px - nx * tailLen;
            morph.tail[b3 + 1] = py - ny * tailLen;
            morph.tail[b3 + 2] = pz - nz * tailLen;

            const isTextStage = isBlessingStage() || stageState.stage === 6 || stageState.stage === 7;
            const near = isTextStage ? 1.0 : clamp(1.0 - dist * 0.38, 0.0, 1.0);
            const baseAlpha = morph.phase === 3 ? 0.98 : 0.82;
            if (isTextStage) {
              const spd = morph.breatheSpeed[i] || 1.2;
              const ph = morph.breathePhase[i] || 0.0;
              const pulse = 0.5 + 0.5 * Math.sin(t * spd + ph);
              const ampA = morph.breatheAmpA[i] || 0.08;
              const ampW = morph.breatheAmpW[i] || 0.10;
              morph.alpha[i] = morph.baseAlpha[i] * fade * appear * (1.0 - ampA + 2.0 * ampA * pulse);
              morph.width[i] = morph.baseWidth[i] * appear * (1.0 - ampW + 2.0 * ampW * pulse);
            } else {
              const breathePhase = t * 2.5 + (i % 97) * 0.15;
              // Fix: Increase minimum intensity to prevent text from disappearing or becoming too faint
              // Old: 0.35 + 0.65 * sin -> Range [-0.3, 1.0] (clamped to 0). Too dark.
              // New: 0.85 + 0.15 * sin -> Range [0.7, 1.0]. Always visible.
              const breatheIntensity = 0.85 + 0.15 * Math.sin(breathePhase);
              const breathePulse = 0.4 + 0.6 * Math.sin(breathePhase * 1.8 + 0.5);
              morph.alpha[i] = baseAlpha * breatheIntensity * fade * (0.15 + 0.85 * near);
              const baseWidth = morph.phase === 3 ? 0.010 : 0.020;
              const widthVariation = morph.phase === 3 ? 0.006 : 0.015;
              morph.width[i] = baseWidth + widthVariation * breathePulse;
            }
          }
          }

          morph.geom.attributes.iHead.needsUpdate = true;
          morph.geom.attributes.iTail.needsUpdate = true;
          morph.geom.attributes.iColor.needsUpdate = true;
          morph.geom.attributes.iAlpha.needsUpdate = true;
          morph.geom.attributes.iWidth.needsUpdate = true;
          morph.geom.attributes.iDelay.needsUpdate = true;
          morph.geom.attributes.iGroup.needsUpdate = true;
        }

        function resetMorphText(useDots) {
          morph.active = true;
          morph.fadeIn = 0;
          morph.useDots = !!useDots;
          morph.phase = morph.useDots ? 3 : 0;
          morph.locked = false;
          morph.frozen = false;
          morph.windActive = false;
          morph.gravityDissolve = false;
          morph.windT = 0;
          morph.windAlphaScale = 1;
          morph.reveal3.set(0, 0, 0);
          morph.liveCount = 0;
          morph.geom.instanceCount = 0;
          morph.mesh.visible = !morph.useDots;
          morph.dotMesh.visible = morph.useDots;
        }

        function startFinale() {
          stageState._finaleTextInited = false;
          stageState._morphExploded = false;
          startSuperGiantShow();
        }

        function startSuperGiantShow() {
          stageState.stage = 7;
          stageState.stageT = 0;
          stageState.fireworksT = 0;
          stageState._superGiant = {
            phase: "g1",
            phaseT: 0,
            r1Idx: -1,
            r1Color: new THREE.Color("#ffcf62"),
            e1: 0,
            e2: 0,
            e3: 0,
            g1Text: 0,
            arcIdx: [],
            arcColor: [],
            arcExploded: 0,
            giantL: -1,
            giantR: -1,
            giantColorL: null,
            giantColorR: null,
            giantsExploded: 0,
            g2Text: 0,
            lastExplodeT: 0, // 新增
          };
          stopMorphImmediately();
          const s = CONFIG.fireworks.speedScale || 1;
          const start = new THREE.Vector3(0, -10.0, 0); // 底部发射
          const v = new THREE.Vector3(0.06 * s, 21.5 * s, 0.02 * s); // 提高初速度，防止过早下坠
          const idx = particles.spawnParticle(start, v, stageState._superGiant.r1Color, 6.2 / s, 0);
          if (idx !== -1) particles.iGroup[idx] = 45;
          stageState._superGiant.r1Idx = idx;
        }

        function updateSuperGiant(dt, t) {
          const sg = stageState._superGiant;
          if (!sg) {
            startStage6Blessing();
            return;
          }

          sg.phaseT += dt;
          const s = CONFIG.fireworks.speedScale || 1;
          const _sevenNdc = updateSuperGiant._sevenNdc || (updateSuperGiant._sevenNdc = new THREE.Vector3());
          const _sevenRay = updateSuperGiant._sevenRay || (updateSuperGiant._sevenRay = new THREE.Vector3());
          const _sevenTmp = updateSuperGiant._sevenTmp || (updateSuperGiant._sevenTmp = new THREE.Vector3());
          const _sevenTmp2 = updateSuperGiant._sevenTmp2 || (updateSuperGiant._sevenTmp2 = new THREE.Vector3());
          const _sevenPos = updateSuperGiant._sevenPos || (updateSuperGiant._sevenPos = Array.from({ length: 7 }, () => new THREE.Vector3()));
          const _sevenCfg = updateSuperGiant._sevenCfg || (updateSuperGiant._sevenCfg = { yNdc: 0.0, xSpread: 0.74 });

          const generateBlessingItems = (startPos, countRange = [1, 3]) => {
             const count = Math.floor(rand(countRange[0], countRange[1] + 0.99));
             const items = [];
             const positions = [];
             
             for (let i = 0; i < count; i++) {
                let x, y;
                let attempts = 0;
                let valid = false;
                while (attempts < 20 && !valid) {
                   x = rand(-15.0, 15.0);
                   y = rand(-2.0, 9.0);
                   valid = true;
                   for (const p of positions) {
                      const dx = x - p.x;
                      const dy = y - p.y;
                      if (dx*dx + dy*dy < 64.0) { // Min dist 8.0
                         valid = false;
                         break;
                      }
                   }
                   attempts++;
                }
                if (!valid) {
                   x = rand(-10.0, 10.0);
                   y = rand(0.0, 5.0);
                }
                positions.push({x, y});
                
                items.push({
                    origin: new THREE.Vector3(x, y, 0),
                    word: pickBlessingWord(),
                    offX: 0,
                    offY: 0,
                    startPos: startPos,
                    delay: i * 0.4,
                    absolute: true
                 });
             }
             return items;
          };

          const computeSevenLayout = (dist = 40.0, worldY = 4.2, margin = 0.74) => {
            if (!camera) return _sevenCfg;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            let lo = -0.85;
            let hi = 0.85;
            for (let it = 0; it < 22; it++) {
              const m = (lo + hi) * 0.5;
              _sevenNdc.set(0, m, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
              if (_sevenTmp.y < worldY) lo = m;
              else hi = m;
            }
            _sevenCfg.yNdc = (lo + hi) * 0.5;

            let xSpread = 0.74;
            for (let fitIt = 0; fitIt < 20; fitIt++) {
              let ok = true;
              for (let i = 0; i < 7; i++) {
                const k = i - 3;
                const xNdc = (k / 3) * xSpread;
                _sevenNdc.set(xNdc, _sevenCfg.yNdc, 0.5).unproject(camera);
                _sevenRay.copy(_sevenNdc).sub(cam);
                const d = _sevenRay.length();
                if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
                else _sevenRay.set(0, 0, -1);
                const p = _sevenPos[i];
                p.copy(cam).addScaledVector(_sevenRay, dist);
                _sevenNdc.copy(p).project(camera);
                if (Math.abs(_sevenNdc.x) > margin || Math.abs(_sevenNdc.y) > margin || _sevenNdc.z < -1 || _sevenNdc.z > 1) ok = false;
              }
              if (ok) break;
              xSpread *= 0.9;
            }
            _sevenCfg.xSpread = xSpread;
            return _sevenCfg;
          };

          const computeSevenPos = (i, u, dist0, dist1, worldY, margin, yStartNdc, bump) => {
            if (!camera) return _sevenPos[i];
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const cfg = computeSevenLayout(dist1, worldY, margin);
            const k = i - 3;
            const s = u * u * (3 - 2 * u);
            if (k === 0) {
              _sevenNdc.set(0, cfg.yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              const endW = _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist1);
              const startW = _sevenTmp2.copy(endW);
              startW.y = endW.y - 6.0;
              return _sevenPos[i].lerpVectors(startW, endW, s);
            }
            const endX = (k / 3) * cfg.xSpread;
            const startX = endX * 0.35;
            const startY = Math.min(yStartNdc, cfg.yNdc - 0.16);
            let x = lerp(startX, endX, s);
            let y = lerp(startY, cfg.yNdc, s);
            const bumpScale = (1.0 - (Math.abs(k) / 3) * 0.35) * (k === 0 ? 0.15 : 1.0);
            y += ((1 - Math.cos(Math.PI * s)) * 0.5) * bump * bumpScale;
            const cap = margin * 0.98;
            x = clamp(x, -cap, cap);
            y = clamp(y, -cap, cap);
            const dist = dist1;
            _sevenNdc.set(x, y, 0.5).unproject(camera);
            _sevenRay.copy(_sevenNdc).sub(cam);
            const d = _sevenRay.length();
            if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
            else _sevenRay.set(0, 0, -1);
            return _sevenPos[i].copy(cam).addScaledVector(_sevenRay, dist);
          };

          if (sg.phase === "g1") {
            const idx = sg.r1Idx;
            // G1 Launch Sound
            if (!sg.g1LaunchPlayed && typeof soundManager !== 'undefined') {
               sg.g1LaunchPlayed = true;
               soundManager.play('launch', { pitch: 1.0 });
            }

            if (idx >= 0 && particles.alive[idx]) {
              const b = idx * 3;
              const p = new THREE.Vector3(particles.pos[b + 0], particles.pos[b + 1], particles.pos[b + 2]);
              const y = p.y;
              const vy = particles.vel[b + 1]; // 获取垂直速度
              const pAdj = updateSuperGiant._tmpG1PAdj || (updateSuperGiant._tmpG1PAdj = new THREE.Vector3());
              pAdj.copy(p);
              if (camera) {
                const up = updateSuperGiant._tmpG1Up || (updateSuperGiant._tmpG1Up = new THREE.Vector3());
                up.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
                pAdj.addScaledVector(up, 1.2);
              } else {
                pAdj.y += 1.2;
              }
              // 上升过程三次爆炸：-5, 1, 8(最高点) - 调整阈值确保能看到两次小爆
              // G1 微调：Giant 提前 0.1s (调整高度阈值)，-5.0 -> -6.2, 1.0 -> -0.2
              // User Request: Another 0.1s earlier.
              // -6.2 -> -7.4
              // -0.2 -> -1.4
              if (!sg.e1 && y > -7.4) {
                sg.e1 = 1;
                // Explode 1: Giant (was Signal)
                // Use 'giant' soundType, which will be forced in explodeAt
                explodeAt(pAdj, sg.r1Color, 9.0 * 1.8, 260, false, false, true, true, 'giant');
              }
              if (!sg.e2 && y > -1.4) {
                sg.e2 = 1;
                // Explode 2: Giant (was Signal)
                explodeAt(pAdj, sg.r1Color, 10.2 * 1.8, 320, false, false, true, true, 'giant');
              }
              // 触发第三次爆炸：到达高度 OR 时间超时 OR 速度即将反向(防止下坠)
              // G1 微调：Giant 提前 0.1s，8.0 -> 6.8 -> 5.6
              if (!sg.e3 && (y > 5.6 || sg.phaseT > 4.5 || (vy < 0.5 && y > 5.0))) {
                sg.e3 = 1;
                // 全屏巨爆，强制二次爆炸
                const pE = updateSuperGiant._tmpG1E3Pos || (updateSuperGiant._tmpG1E3Pos = new THREE.Vector3());
                if (camera) {
                  camera.updateMatrixWorld(true);
                  const cam = camera.position;
                  const dir = updateSuperGiant._tmpG1E3Dir || (updateSuperGiant._tmpG1E3Dir = new THREE.Vector3());
                  dir.copy(p).sub(cam);
                  const d0 = dir.length();
                  if (d0 > 1e-6) dir.multiplyScalar(1.0 / d0);
                  else dir.set(0, 0, -1.0);
                  pE.copy(cam).addScaledVector(dir, 60.0);
                } else {
                  pE.copy(p);
                }
                if (camera) {
                  const up = updateSuperGiant._tmpG1Up || (updateSuperGiant._tmpG1Up = new THREE.Vector3());
                  up.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
                  pE.addScaledVector(up, 1.2);
                } else {
                  pE.y += 1.2;
                }
                sg._g1E3Dist = 60.0;
                // Explode 3: Giant + Secondary (Manual)
                explodeAt(pE, sg.r1Color, 32.0, 1500, true, 2, true, false, 'giant');
                if (typeof soundManager !== 'undefined') {
                   // Secondary 延迟改为 1.5s
                   soundManager.play('secondary', { delay: 1500, force: true });
                }
                
                particles.kill(idx);
                sg.r1Idx = -1;
                sg.g1Origin = p.clone();
                sg.phase = "g1_after";
                sg.phaseT = 0;
                sg.lastExplodeT = t;
              }
            } else {
              sg.phase = "g1_after";
              sg.phaseT = 0;
              sg.lastExplodeT = t;
            }
          } else if (sg.phase === "g1_after") {
            // 在烟花消散期间插入祝福语
            // Delay increased from 0.1 to 2.5s to wait for secondary explosions
            if (!sg.g1Text && sg.phaseT > 2.5) {
              sg.g1Text = 1;
              
              // Capture active firework particles for morph effect
              const srcParticles = captureActiveParticles(4000);
              killActiveParticles(); // Kill them to complete the illusion
              
              const items = generateBlessingItems(sg.g1Origin);
              triggerBlessingTexts(items, srcParticles, 2.25); // Extended duration (+1.0s)
            }
            // 稍后触发消散 (Delayed to ensure 2.5s stay)
            if (!sg.g1Wind && sg.phaseT > 6.0) { // Was 5.0, increased to match extended duration
              sg.g1Wind = 1;
              triggerBlessingDissolve();
            }
            
            // 等待较长时间让第一个完全消散 (8.5s)
            if (sg.phaseT > 8.5) { // Was 7.5
              sg.phase = "g2";
              sg.phaseT = 0;
              sg.g2 = null;
              stopMorphImmediately();
            }
          } else if (sg.phase === "g2") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;

            if (!sg.g2) {
              const dist = 60.0;
              const margin = 0.80;
              const cfg = computeSevenLayout(dist, 3.6, 0.74);
              const lineY = clamp(cfg.yNdc, -0.25, 0.6);
              const xSpread = Math.min(cfg.xSpread || 0.72, 0.74);

              sg._arcPower = 16.0;
              sg._arcCount = 600;
              sg._giantPower = 36.4;
              sg._giantCount = 1300;

              sg.g2 = {
                phase: "small_fly",
                t: 0,
                dist,
                margin,
                lineY,
                xSpread,
                smallDur: 1.35,
                smallStartY: lineY - 0.26,
                smallEndY: lineY,
                smallExplodeY: lineY,
                smallBump: 0.06,
                smallIdx: Array(7).fill(-1),
                smallColor: Array(7).fill(null),
                bigDur: 1.8,
                bigStartY: -0.86,
                bigEndY: clamp(lineY + 0.34 * 1.3, -0.15, 0.86),
                bigX: 0.42,
                bigIdx: [-1, -1],
                bigColor: [new THREE.Color("#ffcc66"), new THREE.Color("#ffcc66")],
              };

              for (let i = 0; i < 7; i++) {
                const k = i - 3;
                const x = (k / 3) * xSpread;
                const y = sg.g2.smallStartY;
                _sevenNdc.set(clamp(x, -margin, margin), clamp(y, -margin, margin), 0.5).unproject(camera);
                _sevenRay.copy(_sevenNdc).sub(cam);
                const d = _sevenRay.length();
                if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
                else _sevenRay.set(0, 0, -1);
                const p = _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
                const c = pickNeonColor();
                const idx = particles.spawnParticle(p, new THREE.Vector3(0, 0, 0), c, 6.0 / s, 4);
                if (idx !== -1) particles.iGroup[idx] = 42;
                sg.g2.smallIdx[i] = idx;
                sg.g2.smallColor[i] = c;
              }
              
              // G2 Small Launch: 7x Launch with 20% volume
              if (typeof soundManager !== 'undefined') {
                 // Play 7 times or just representatively?
                 // User said "use 20% volume launch".
                 // Let's play 3-4 to simulate "many" but not overwhelm, or just loop 7 times?
                 // 7 times with small delays might sound good.
                 for (let i=0; i<7; i++) {
                    soundManager.play('launch', { pitch: rand(0.9, 1.2), volume: 0.2, force: true, delay: i * 20 });
                 }
              }
            }

            const g2 = sg.g2;
            g2.t += dt;
            const dtSafe = clamp(dt, 0, 0.05);

            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            const smooth = (u) => u * u * (3 - 2 * u);

            if (g2.phase === "small_fly") {
              const uNow = clamp(g2.smallDur > 1e-6 ? g2.t / g2.smallDur : 1.0, 0, 1);
              const uNext = clamp(g2.smallDur > 1e-6 ? (g2.t + dtSafe) / g2.smallDur : 1.0, 0, 1);
              const sNow = smooth(uNow);
              const sNext = smooth(uNext);

              for (let i = 0; i < 7; i++) {
                const idx = g2.smallIdx[i];
                if (idx < 0 || !particles.alive[idx]) continue;
                const k = i - 3;
                const x = (k / 3) * g2.xSpread;
                const bumpScale = 1.0 - (Math.abs(k) / 3) * 0.35;
                const bumpNow = Math.sin(Math.PI * sNow) * g2.smallBump * bumpScale;
                const bumpNext = Math.sin(Math.PI * sNext) * g2.smallBump * bumpScale;
                const yNow = lerp(g2.smallStartY, g2.smallExplodeY, sNow) - bumpNow;
                const yNext = lerp(g2.smallStartY, g2.smallExplodeY, sNext) - bumpNext;

                const pNow = placeAt(clamp(x, -g2.margin, g2.margin), clamp(yNow, -g2.margin, g2.margin), g2.dist).clone();
                const pNext = _sevenTmp2.copy(placeAt(clamp(x, -g2.margin, g2.margin), clamp(yNext, -g2.margin, g2.margin), g2.dist));
                const b = idx * 3;
                particles.pos[b + 0] = pNow.x;
                particles.pos[b + 1] = pNow.y;
                particles.pos[b + 2] = pNow.z;
                const dvx = (pNext.x - pNow.x) / Math.max(1e-6, dtSafe);
                const dvy = (pNext.y - pNow.y) / Math.max(1e-6, dtSafe);
                const dvz = (pNext.z - pNow.z) / Math.max(1e-6, dtSafe);
                particles.vel[b + 0] = dvx;
                particles.vel[b + 1] = dvy;
                particles.vel[b + 2] = dvz;
              }

              if (uNow >= 1.0 || g2.t > g2.smallDur + 0.35) {
                for (let i = 0; i < 7; i++) {
                  const idx = g2.smallIdx[i];
                  if (idx < 0 || !particles.alive[idx]) continue;
                  const k = i - 3;
                  const x = (k / 3) * g2.xSpread;
                const p = placeAt(clamp(x, -g2.margin, g2.margin), clamp(g2.smallExplodeY, -g2.margin, g2.margin), g2.dist);
                const b = idx * 3;
                particles.pos[b + 0] = p.x;
                particles.pos[b + 1] = p.y;
                particles.pos[b + 2] = p.z;
                
                // G2 Small Explode (7x): Use 'singal'
                // User Request: 4x Signal with high density random interval
                // Total 7 explosions. i = 0..6
                // Trigger sound for 4 of them: 0, 2, 4, 6
                if (typeof soundManager !== 'undefined') {
                   if (i % 2 === 0) {
                       soundManager.play('singal', { delay: randInt(0, 100), force: true });
                   }
                }
                
                explodeAt(p, g2.smallColor[i], sg._arcPower, sg._arcCount, false, false, false, true);
                particles.kill(idx);
                g2.smallIdx[i] = -1;
              }

                const y0 = g2.bigStartY;
                const xl = -g2.bigX;
                const xr = g2.bigX;
                // 让两只火箭从左右对称点直接发射，而不是从边缘向中心汇聚
                // 修改: pL和pR直接定位在发射点，不再需要从远处飞入
                const pL = placeAt(xl, y0, g2.dist);
                const pR = placeAt(xr, y0, g2.dist);
                
                sg.giantColorL = g2.bigColor[0];
                sg.giantColorR = g2.bigColor[1];
                
                // 给左右火箭不同的垂直初速度，或略微倾斜，避免完全平行
                // 这里使用 placeAt 计算两个位置，然后直接赋予向上的速度
                // 注意：spawnParticle 需要 p, v, c, life, kind
                // 我们需要计算一个向上的速度向量 v
                // 之前的逻辑是计算 pNow 和 pNext 来推导速度，因为是贝塞尔曲线或线性插值移动
                // 现在我们改为物理模拟发射
                
                // 重新设计 big_fly 阶段：
                // 使用物理更新，而非插值更新位置
                // 这样可以有更自然的拖尾和运动
                
                const s = CONFIG.fireworks.speedScale || 1;
                // 计算目标高度 g2.bigEndY 对应的垂直速度
                // h = v^2 / 2g => v = sqrt(2gh)
                // 这里我们简单给一个向上的速度，并在 big_fly 中更新物理
                // 但原代码逻辑是插值控制 (pNow, pNext)
                
                // 保持原有的插值控制逻辑，但修改 xs 数组，使其在 update 循环中保持 x 不变（垂直上升）
                // 原代码: const xs = [-g2.bigX, g2.bigX]; pNow = placeAt(x...)
                // 只要 xs 在 update 中是固定的，就是垂直上升
                
                // 关键点：检查之前的 pL, pR 是否有位移
                // 原代码 pL = placeAt(xl, y0...), xl = -g2.bigX
                // 只要 big_fly 阶段 x 保持为 -g2.bigX 和 g2.bigX，就是垂直的
                // 之前的 bug 可能是因为 xs 的定义或者插值中 x 发生了变化？
                // 检查 big_fly 中的 xs: const xs = [-g2.bigX, g2.bigX];
                // 看起来 x 是固定的。
                // 等等，用户说 "从同一个点发射的...导致右边那只火箭...从左往右"
                // 这意味着初始位置 pL 和 pR 可能被错误地设置为了同一个点
                // 或者 big_fly 里的逻辑让它们动了
                
                // 检查 spawnParticle 时的位置:
                // const pL = placeAt(xl, y0, g2.dist);
                // const pR = placeAt(xr, y0, g2.dist);
                // xl = -0.42, xr = 0.42. 它们是不同的。
                
                // 仔细看之前的 spawn 代码:
                // g2.bigIdx[0] = particles.spawnParticle(pL...);
                // g2.bigIdx[1] = particles.spawnParticle(pR...);
                
                // 难道是 big_fly 阶段的 xs 定义有问题？
                // const xs = [-g2.bigX, g2.bigX];
                // x = xs[j]
                // pNow = placeAt(x...)
                // 看起来是对的。
                
                // 唯一的可能性是 spawnParticle 时的 pL, pR 实际上是相同的？
                // xl = -g2.bigX, xr = g2.bigX. g2.bigX = 0.42.
                // 除非 g2.bigX 被修改了？
                
                // 或者是 placeAt 函数的问题？
                // placeAt 使用 _sevenNdc 和 _sevenRay
                // const placeAt = (xNdc, yNdc...)
                
                // 让我们再次检查 spawn 时的代码块
                // 发现之前的代码块中：
                // const xl = -g2.bigX;
                // const xr = g2.bigX;
                // const pL = placeAt(xl, y0, g2.dist);
                // const pR = placeAt(xr, y0, g2.dist);
                
                // 注意：placeAt 内部使用了 _sevenNdc, _sevenRay, _sevenTmp
                // 如果 placeAt 返回的是 _sevenTmp 的引用，并且没有拷贝
                // 那么 pL 和 pR 都会指向同一个对象（最后一次计算的结果）！
                // 检查 placeAt 实现:
                // return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
                // 是的！它返回 _sevenTmp！
                // 所以 pL 和 pR 是同一个对象引用，值是最后一次调用 (pR) 的值。
                // 所以两个火箭都从 pR 的位置发射。
                // 这是一个经典的引用错误。
                
                // 修复：使用 clone() 或者 copy 到新向量
                
                const pL_val = placeAt(xl, y0, g2.dist).clone();
                const pR_val = placeAt(xr, y0, g2.dist).clone();
                
                sg.giantColorL = g2.bigColor[0];
                sg.giantColorR = g2.bigColor[1];
                g2.bigIdx[0] = particles.spawnParticle(pL_val, new THREE.Vector3(0, 0, 0), sg.giantColorL, 7.0 / s, 4);
                g2.bigIdx[1] = particles.spawnParticle(pR_val, new THREE.Vector3(0, 0, 0), sg.giantColorR, 7.0 / s, 4);
                if (g2.bigIdx[0] !== -1) particles.iGroup[g2.bigIdx[0]] = 44;
                if (g2.bigIdx[1] !== -1) particles.iGroup[g2.bigIdx[1]] = 44;
                sg.giantL = g2.bigIdx[0];
                sg.giantR = g2.bigIdx[1];
                
                // G2 Big Launch: 2x Launch, 10ms gap, force: true
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('launch', { pitch: 1.0, force: true });
                   soundManager.play('launch', { pitch: 1.05, delay: 10, force: true });
                }

                g2.phase = "big_fly";
                g2.t = 0;
              }
            } else if (g2.phase === "big_fly") {
              const uNow = clamp(g2.bigDur > 1e-6 ? g2.t / g2.bigDur : 1.0, 0, 1);
              const uNext = clamp(g2.bigDur > 1e-6 ? (g2.t + dtSafe) / g2.bigDur : 1.0, 0, 1);
              const sNow = smooth(uNow);
              const sNext = smooth(uNext);
              const yNow = lerp(g2.bigStartY, g2.bigEndY, sNow);
              const yNext = lerp(g2.bigStartY, g2.bigEndY, sNext);

              const xs = [-g2.bigX, g2.bigX];
              for (let j = 0; j < 2; j++) {
                const idx = g2.bigIdx[j];
                if (idx < 0 || !particles.alive[idx]) continue;
                const x = xs[j];
                const pNow = placeAt(clamp(x, -g2.margin, g2.margin), clamp(yNow, -g2.margin, g2.margin), g2.dist).clone();
                const pNext = _sevenTmp2.copy(placeAt(clamp(x, -g2.margin, g2.margin), clamp(yNext, -g2.margin, g2.margin), g2.dist));
                const b = idx * 3;
                particles.pos[b + 0] = pNow.x;
                particles.pos[b + 1] = pNow.y;
                particles.pos[b + 2] = pNow.z;
                const dvx = (pNext.x - pNow.x) / Math.max(1e-6, dtSafe);
                const dvy = (pNext.y - pNow.y) / Math.max(1e-6, dtSafe);
                const dvz = (pNext.z - pNow.z) / Math.max(1e-6, dtSafe);
                particles.vel[b + 0] = dvx;
                particles.vel[b + 1] = dvy;
                particles.vel[b + 2] = dvz;
              }

              if (uNow >= 1.0 || g2.t > g2.bigDur + 0.5) {
                sg._giantNdcY = g2.bigEndY;
                const xs2 = [-g2.bigX, g2.bigX];
                // G2 Big Explode: 2x Giant (10ms gap) + 2x Secondary (1.5s delay)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('giant', { pitch: 0.9, force: true });
                   soundManager.play('giant', { pitch: 0.95, delay: 10, force: true });
                   // Secondary delayed by 1.5s
                   soundManager.play('secondary', { volume: 0.6, delay: 1500, force: true });
                   soundManager.play('secondary', { volume: 0.6, delay: 1500, force: true });
                }

                for (let j = 0; j < 2; j++) {
                  const idx = g2.bigIdx[j];
                  if (idx < 0 || !particles.alive[idx]) continue;
                  const p = placeAt(xs2[j], g2.bigEndY, g2.dist);
                  // Pass playSound=false to explodeAt because we handled it manually
                  // Pass 'giant' as soundType just in case
                  explodeAt(p, g2.bigColor[j], sg._giantPower, sg._giantCount, true, 2, false, true, 'giant');
                  particles.kill(idx);
                  g2.bigIdx[j] = -1;
                }
                sg.giantL = -1;
                sg.giantR = -1;
                sg.phase = "g2_after";
                sg.phaseT = 0;
                sg.lastExplodeT = t;
              }
            }
          } else if (sg.phase === "g2_after") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g2Text && sg.phaseT > 0.1) {
              sg.g2Text = 1;
              const g2 = sg.g2;
              const y = sg._giantNdcY || g2.bigEndY;
              const pCenter = placeAt(0, y, g2.dist).clone();

              const items = generateBlessingItems(pCenter);
              triggerBlessingTexts(items);
            }
            if (!sg.g2Wind && sg.phaseT > 8.0) {
              sg.g2Wind = 1;
              triggerBlessingDissolve();
            }
            if (sg.phaseT > 10.5) {
              sg.phase = "g3";
              sg.phaseT = 0;
              sg.g3 = null;
              stopMorphImmediately();
            }
          } else if (sg.phase === "g3") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const dtSafe = clamp(dt, 0, 0.05);
            const placeAt = (xNdc, yNdc, dist, out) => {
              const o = out || _sevenTmp;
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return o.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g3) {
              const dist = 62.0;
              const cfg = computeSevenLayout(dist, 4.0, 0.78);
              const baseY = clamp(cfg.yNdc + 0.06, -0.25, 0.55);
              sg.g3 = {
                phase: "spiral",
                t: 0,
                dist,
                baseY,
                dur: 8.2,
                aIdx: -1,
                bIdx: -1,
                aColor: new THREE.Color("#63f4ff"),
                bColor: new THREE.Color("#ff6ad5"),
                endA: new THREE.Vector3(),
                endB: new THREE.Vector3(),
                domeN: 11,
                domeI: 0,
                pulseI: 0,
                popAcc: 0,
                nextPopT: 0.2, // Initial random delay
                // Sound flags
                whistlePlayed: false
                // Removed crackleId loop
              };
              // Symmetric launch: Start from wide positions to match spiral start
              const pA = placeAt(0.35, baseY - 0.58, dist, _sevenTmp);
              const pB = placeAt(-0.35, baseY - 0.58, dist, _sevenTmp2);
              sg.g3.aIdx = particles.spawnParticle(pA, new THREE.Vector3(0, 0, 0), sg.g3.aColor, 8.5 / s, 4);
              sg.g3.bIdx = particles.spawnParticle(pB, new THREE.Vector3(0, 0, 0), sg.g3.bColor, 8.5 / s, 4);
              if (sg.g3.aIdx !== -1) particles.iGroup[sg.g3.aIdx] = 41;
              if (sg.g3.bIdx !== -1) particles.iGroup[sg.g3.bIdx] = 41;
            }

            const g3 = sg.g3;
            g3.t += dt;

            // Delayed Whistle (0.5s)
            if (!g3.whistlePlayed && g3.t > 0.5 && typeof soundManager !== 'undefined') {
               g3.whistlePlayed = true;
               soundManager.play('launch', { pitch: 1.7, volume: 0.6, force: true }); // Whistle
            }

            if (g3.phase === "spiral") {
              const uNow = clamp(g3.dur > 1e-6 ? g3.t / g3.dur : 1.0, 0, 1);
              const uNext = clamp(g3.dur > 1e-6 ? (g3.t + dtSafe) / g3.dur : 1.0, 0, 1);
              const sNow = uNow * uNow * (3 - 2 * uNow);
              const sNext = uNext * uNext * (3 - 2 * uNext);
              const A0 = 0.35; // Start wide (parallel spiral)
              const A1 = 0.35;
              const ANow = lerp(A0, A1, sNow);
              const ANext = lerp(A0, A1, sNext);
              const y0 = g3.baseY - 0.58;
              const y1 = clamp(g3.baseY + 0.68, -0.2, 0.82);
              const yNow = lerp(y0, y1, sNow) + Math.sin(sNow * Math.PI * 4) * 0.03;
              const yNext = lerp(y0, y1, sNext) + Math.sin(sNext * Math.PI * 4) * 0.03;
              const w = Math.PI * 5.0;
              const thNow = w * sNow;
              const thNext = w * sNext;

              const xA = ANow * Math.cos(thNow);
              const xB = ANow * Math.cos(thNow + Math.PI);
              const xAN = ANext * Math.cos(thNext);
              const xBN = ANext * Math.cos(thNext + Math.PI);

              const pA = placeAt(clamp(xA, -0.84, 0.84), clamp(yNow, -0.84, 0.84), g3.dist, _sevenTmp);
              const pB = placeAt(clamp(xB, -0.84, 0.84), clamp(yNow, -0.84, 0.84), g3.dist, _sevenTmp2);
              const pAN = placeAt(clamp(xAN, -0.84, 0.84), clamp(yNext, -0.84, 0.84), g3.dist, updateSuperGiant._tmpG3A2 || (updateSuperGiant._tmpG3A2 = new THREE.Vector3()));
              const pBN = placeAt(clamp(xBN, -0.84, 0.84), clamp(yNext, -0.84, 0.84), g3.dist, updateSuperGiant._tmpG3B2 || (updateSuperGiant._tmpG3B2 = new THREE.Vector3()));

              if (g3.aIdx >= 0 && particles.alive[g3.aIdx]) {
                const b = g3.aIdx * 3;
                particles.pos[b + 0] = pA.x;
                particles.pos[b + 1] = pA.y;
                particles.pos[b + 2] = pA.z;
                particles.vel[b + 0] = (pAN.x - pA.x) / Math.max(1e-6, dtSafe);
                particles.vel[b + 1] = (pAN.y - pA.y) / Math.max(1e-6, dtSafe);
                particles.vel[b + 2] = (pAN.z - pA.z) / Math.max(1e-6, dtSafe);
              }
              if (g3.bIdx >= 0 && particles.alive[g3.bIdx]) {
                const b = g3.bIdx * 3;
                particles.pos[b + 0] = pB.x;
                particles.pos[b + 1] = pB.y;
                particles.pos[b + 2] = pB.z;
                particles.vel[b + 0] = (pBN.x - pB.x) / Math.max(1e-6, dtSafe);
                particles.vel[b + 1] = (pBN.y - pB.y) / Math.max(1e-6, dtSafe);
                particles.vel[b + 2] = (pBN.z - pB.z) / Math.max(1e-6, dtSafe);
              }

              g3.popAcc += dt;
              // User Request: Randomize density.
              // Mean ~0.25 (dense). Range [0.15, 0.35]
              while (g3.popAcc >= g3.nextPopT) {
                g3.popAcc -= g3.nextPopT;
                g3.nextPopT = rand(0.15, 0.35); // Next random interval
                
                let x = 0;
                let y = 0;
                for (let it = 0; it < 8; it++) {
                  x = rand(-0.86, 0.86);
                  y = rand(-0.12, 0.86);
                  const dxA = x - xA;
                  const dyA = y - yNow;
                  const dxB = x - xB;
                  const dyB = y - yNow;
                  if (dxA * dxA + dyA * dyA > 0.06 && dxB * dxB + dyB * dyB > 0.06) break;
                }
                const p = placeAt(x, y, g3.dist, updateSuperGiant._tmpG3Pop || (updateSuperGiant._tmpG3Pop = new THREE.Vector3()));
                const c = new THREE.Color().setHSL(rand(0.02, 0.62), 0.95, 0.62);
                // G3 Spiral Small Pop: Signal (force: true)
                explodeAt(p, c, 64.0, 160, false, false, true, false, 'singal');
              }

              if (uNow >= 1.0 || g3.t > g3.dur + 0.35) {
                // if (g3.crackleId && typeof soundManager !== 'undefined') soundManager.stopLoop(g3.crackleId); // Removed
                g3.endA.copy(pA);
                g3.endB.copy(pB);
                if (g3.aIdx >= 0) particles.kill(g3.aIdx);
                if (g3.bIdx >= 0) particles.kill(g3.bIdx);
                g3.aIdx = -1;
                g3.bIdx = -1;
                
                // G3 Big Explode: 2x Giant (10ms) + 2x Secondary REMOVED (moved to Burst2)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('giant', { pitch: 0.9, force: true });
                   soundManager.play('giant', { pitch: 0.95, delay: 10, force: true });
                   // Removed secondary here
                }

                explodeAt(g3.endA, g3.aColor, 34.0, 1200, true, 2, false, true);
                explodeAt(g3.endB, g3.bColor, 34.0, 1200, true, 2, false, true);
                g3.phase = "burst2";
                g3.t = 0;
              }
            } else if (g3.phase === "burst2") {
              if (g3.t > 0.25) {
                // Secondary visual explosion (Gold flash)
                // Use 'singal' as requested for secondary sound, force: true
                // Play 'secondary' sound (crackle) here to match visual "secondary explosion"
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('secondary', { volume: 0.6, force: true });
                   soundManager.play('secondary', { volume: 0.6, delay: 100, force: true });
                }
                
                explodeAt(g3.endA, new THREE.Color("#ffd36a"), 22.0, 560, true, 1, true, true, 'singal');
                explodeAt(g3.endB, new THREE.Color("#ffd36a"), 22.0, 560, true, 1, true, true, 'singal');
                g3.phase = "dome";
                g3.t = 0;
                g3.domeI = 0;
              }
            } else if (g3.phase === "dome") {
              const step = 0.085;
              while (g3.domeI < g3.domeN && g3.t >= g3.domeI * step) {
                const u = g3.domeN <= 1 ? 0.5 : g3.domeI / (g3.domeN - 1);
                const th = lerp(-Math.PI * 0.94, -Math.PI * 0.06, u);
                const r = 0.62;
                const x = Math.cos(th) * r;
                const y = g3.baseY + 0.32 + Math.sin(th) * r * 0.55;
                const p = placeAt(clamp(x, -0.84, 0.84), clamp(y, -0.25, 0.85), g3.dist, updateSuperGiant._tmpG3D || (updateSuperGiant._tmpG3D = new THREE.Vector3()));
                // G3 Dome: Signal (force: true)
                explodeAt(p, new THREE.Color("#a9ffe8"), 15.0, 260, false, false, true, true, 'singal');
                g3.domeI++;
              }
              if (g3.domeI >= g3.domeN && g3.t > g3.domeN * step + 0.55) {
                g3.phase = "pulse";
                g3.t = 0;
                g3.pulseI = 0;
              }
            } else if (g3.phase === "pulse") {
              const step = 0.12;
              while (g3.pulseI < 6 && g3.t >= g3.pulseI * step) {
                const x = rand(-0.22, 0.22);
                const y = g3.baseY + rand(0.18, 0.56);
                const p = placeAt(x, y, g3.dist, updateSuperGiant._tmpG3P || (updateSuperGiant._tmpG3P = new THREE.Vector3()));
                explodeAt(p, new THREE.Color("#e7ffff"), 10.0, 110, false, false, true, true);
                g3.pulseI++;
              }
              if (g3.pulseI >= 6 && g3.t > 1.1) {
                sg.phase = "g3_after";
                sg.phaseT = 0;
                sg.lastExplodeT = t;
              }
            }
          } else if (sg.phase === "g3_after") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            // g3: 螺旋对撞，中心爆发
            // Delay increased to 3.5s to let dome/pulse effects finish
            if (!sg.g3Text && sg.phaseT > 3.5) {
              sg.g3Text = 1;
              const g3 = sg.g3;
              const pCenter = placeAt(0, g3.baseY + 0.5, g3.dist).clone();
              
              // Capture active firework particles
              const srcParticles = captureActiveParticles(3000);
              killActiveParticles();
              
              const items = generateBlessingItems(pCenter);
              triggerBlessingTexts(items, srcParticles);
            }
            if (!sg.g3Wind && sg.phaseT > 5.0) {
              sg.g3Wind = 1;
              triggerBlessingDissolve();
            }
            if (sg.phaseT > 7.5) {
              sg.phase = "g4";
              sg.phaseT = 0;
              sg.g4 = null;
              stopMorphImmediately();
            }
          } else if (sg.phase === "g4") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const dtSafe = clamp(dt, 0, 0.05);
            const placeAt = (xNdc, yNdc, dist, out) => {
              const o = out || _sevenTmp;
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return o.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g4) {
              const dist = 62.0;
              const cfg = computeSevenLayout(dist, 4.0, 0.84);
              const baseY = clamp(cfg.yNdc + 0.02, -0.25, 0.5);
              const n = 15;
              sg.g4 = {
                phase: "fan_fly",
                t: 0,
                dist,
                baseY,
                n,
                dur: 1.6,
                idx: Array(n).fill(-1),
                col: Array(n).fill(null),
                apexY: new Float32Array(n),
                ringT: 0,
                // Sound flags
                explodeAcc: 0, 
              };
              
              // G4 Launch: 15 rockets, but only 2 Launch sounds (10ms gap)
              if (typeof soundManager !== 'undefined') {
                 soundManager.play('launch', { pitch: 1.0, force: true });
                 soundManager.play('launch', { pitch: 1.05, delay: 10, force: true });
              }

              for (let i = 0; i < n; i++) {
                const u = n <= 1 ? 0.5 : i / (n - 1);
                const x = lerp(-0.75, 0.75, u);
                const y0 = -0.78;
                const yA = lerp(-0.08, 0.24, 1.0 - Math.abs(u * 2 - 1));
                sg.g4.apexY[i] = clamp(baseY + yA, -0.15, 0.52);
                const p = placeAt(x, y0, dist, _sevenTmp);
                const c = new THREE.Color().setHSL(lerp(0.04, 0.12, u), 0.92, 0.62);
                sg.g4.col[i] = c;
                const idx = particles.spawnParticle(p, new THREE.Vector3(0, 0, 0), c, 7.5 / s, 4);
                sg.g4.idx[i] = idx;
                if (idx !== -1) particles.iGroup[idx] = 46;
              }
            }

            const g4 = sg.g4;
            g4.t += dt;
            if (g4.phase === "fan_fly") {
              const uNow = clamp(g4.dur > 1e-6 ? g4.t / g4.dur : 1.0, 0, 1);
              const uNext = clamp(g4.dur > 1e-6 ? (g4.t + dtSafe) / g4.dur : 1.0, 0, 1);
              const sNow = uNow * uNow * (3 - 2 * uNow);
              const sNext = uNext * uNext * (3 - 2 * uNext);
              for (let i = 0; i < g4.n; i++) {
                const idx = g4.idx[i];
                if (idx < 0 || !particles.alive[idx]) continue;
                const uu = g4.n <= 1 ? 0.5 : i / (g4.n - 1);
                const x = lerp(-0.75, 0.75, uu);
                const y0 = -0.78;
                const y1 = g4.apexY[i];
                const yNow = lerp(y0, y1, sNow);
                const yNext = lerp(y0, y1, sNext);
                const pNow = placeAt(x, yNow, g4.dist, _sevenTmp);
                const pNext = placeAt(x, yNext, g4.dist, _sevenTmp2);
                const b = idx * 3;
                particles.pos[b + 0] = pNow.x;
                particles.pos[b + 1] = pNow.y;
                particles.pos[b + 2] = pNow.z;
                particles.vel[b + 0] = (pNext.x - pNow.x) / Math.max(1e-6, dtSafe);
                particles.vel[b + 1] = (pNext.y - pNow.y) / Math.max(1e-6, dtSafe);
                particles.vel[b + 2] = (pNext.z - pNow.z) / Math.max(1e-6, dtSafe);
              }
              if (uNow >= 1.0 || g4.t > g4.dur + 0.25) {
                for (let i = 0; i < g4.n; i++) {
                  const idx = g4.idx[i];
                  if (idx < 0 || !particles.alive[idx]) continue;
                  const uu = g4.n <= 1 ? 0.5 : i / (g4.n - 1);
                  const x = lerp(-0.75, 0.75, uu);
                  const p = placeAt(x, g4.apexY[i], g4.dist, _sevenTmp);
                  
                  // G4 Small Explode: 15 explosions
                  // User Request: 1x Secondary + 5x Signal (random interval)
                  // i goes from 0 to 14
                  
                  // Manual Sound Logic
                  if (typeof soundManager !== 'undefined') {
                     // 1. One Secondary at the center (i=7)
                     if (i === 7) {
                         soundManager.play('secondary', { force: true });
                     }
                     
                     // 2. Five Signals (indices 0, 3, 6, 9, 12) with random delay (0-150ms)
                     if (i % 3 === 0) {
                         soundManager.play('singal', { delay: randInt(0, 150), force: true });
                     }
                  }
                  
                  // Pass playSound=false to explodeAt to avoid extra sounds
                  explodeAt(p, g4.col[i], 12.0, 220, false, false, false, true);
                  particles.kill(idx);
                  g4.idx[i] = -1;
                }
                g4.phase = "crown";
                g4.t = 0;
                g4.ringT = 0;
              }
            } else if (g4.phase === "crown") {
              g4.ringT += dt;
              const cY = clamp(g4.baseY + 0.36, -0.05, 0.72);
              if (!g4._ringDone && g4.ringT > 0.9) {
                g4._ringDone = 1;
                
                // Play sound for Crown formation (Medium or Singal)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('medium', { volume: 0.7, force: true });
                }

                const center = placeAt(0, cY, g4.dist, updateSuperGiant._tmpG4C || (updateSuperGiant._tmpG4C = new THREE.Vector3()));
                const ringN = 26;
                const r = 0.34;
                for (let i = 0; i < ringN; i++) {
                  const th = (i / ringN) * Math.PI * 2;
                  const x = Math.cos(th) * r;
                  const y = cY + Math.sin(th) * r * 0.66;
                  const p = placeAt(x, y, g4.dist, updateSuperGiant._tmpG4R || (updateSuperGiant._tmpG4R = new THREE.Vector3()));
                  // Ring small explosions - silent
                  explodeAt(p, new THREE.Color("#ffdca0"), 10.0, 120, false, false, true, true);
                }
                for (let i = 0; i < 12; i++) {
                  const th = (i / 12) * Math.PI * 2 + 0.12;
                  const x = Math.cos(th) * (r * 0.78);
                  const y = cY + Math.sin(th) * (r * 0.52);
                  const p = placeAt(x, y, g4.dist, updateSuperGiant._tmpG4S || (updateSuperGiant._tmpG4S = new THREE.Vector3()));
                  explodeAt(p, new THREE.Color("#f6ffff"), 7.0, 70, false, false, true, true);
                }
                // G4 Big Explode: Giant + Secondary (1.5s delay)
                explodeAt(center, new THREE.Color("#ffe7b8"), 40.0, 1500, true, 2, true, true, 'giant');
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('secondary', { delay: 1500, force: true });
                }

                sg.phase = "g4_after";
                sg.phaseT = 0;
                sg.lastExplodeT = t;
              }
            }
          } else if (sg.phase === "g4_after") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g4Text && sg.phaseT > 0.1) {
              sg.g4Text = 1;
              const g4 = sg.g4;
              const pCenter = placeAt(0, g4.baseY + 0.36, g4.dist).clone();
              
              const items = generateBlessingItems(pCenter);
              triggerBlessingTexts(items);
            }
            if (!sg.g4Wind && sg.phaseT > 4.5) { // Adjusted from 7.5 to 4.5
              sg.g4Wind = 1;
              triggerBlessingDissolve();
            }
            if (sg.phaseT > 7.5) { // Adjusted from 10.0 to 7.5
              sg.phase = "g5";
              sg.phaseT = 0;
              sg.g5 = null;
              stopMorphImmediately();
            }
          } else if (sg.phase === "g5") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const dtSafe = clamp(dt, 0, 0.05);
            const placeAt = (xNdc, yNdc, dist, out) => {
              const o = out || _sevenTmp;
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return o.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g5) {
              const dist = 62.0;
              const cfg = computeSevenLayout(dist, 4.0, 0.84);
              const baseY = clamp(cfg.yNdc + 0.02, -0.25, 0.48);
              const n = 5;
              const sx = new Float32Array(n);
              const sy = new Float32Array(n);
              const ex = new Float32Array(n);
              const ey = new Float32Array(n);
              for (let i = 0; i < n; i++) {
                const u = n <= 1 ? 0.5 : i / (n - 1);
                const lane = u * 2 - 1;
                const xJ = rand(-0.02, 0.02);
                sx[i] = -0.90 + lane * 0.02 + xJ;
                ex[i] = 0.90 + lane * 0.02 + xJ;
                sy[i] = clamp(baseY + 0.70 + lane * 0.18 + rand(-0.018, 0.018), -0.1, 0.86);
                ey[i] = clamp(baseY - 0.12 + lane * 0.12 + rand(-0.02, 0.02), -0.5, 0.65);
              }
              sg.g5 = {
                phase: "meteor",
                t: 0,
                dist,
                baseY,
                n,
                dur: 6.8,
                idx: Array(n).fill(-1),
                sx,
                sy,
                ex,
                ey,
                exploded: new Uint8Array(n),
                chargeDur: 0.8,
                lIdx: -1,
                rIdx: -1,
                lCol: new THREE.Color("#cfe7ff"),
                rCol: new THREE.Color("#ffcc66"),
                tmpL: new THREE.Vector3(),
                tmpR: new THREE.Vector3(),
                water: {
                  acc: 0,
                  lanes: null,
                  dropIdx: [],
                  dropLane: [],
                  lastS: -0.04,
                  explodeCursor: 0,
                  exL: 0,
                  exR: 0,
                  exMinX: 1e9,
                  exMaxX: -1e9
                  // Removed loopAcc
                },
              };
              
              // G5 Launch: One single launch sound (force: true)
              if (typeof soundManager !== 'undefined') {
                 soundManager.play('launch', { pitch: 1.0, force: true });
              }

              for (let i = 0; i < n; i++) {
                const p = placeAt(sx[i], sy[i], dist, _sevenTmp);
                const c = new THREE.Color("#eaf2ff").offsetHSL(rand(-0.02, 0.02), rand(-0.06, 0.06), rand(-0.08, -0.02));
                const idx = particles.spawnParticle(p, new THREE.Vector3(0, 0, 0), c, 6.5 / s, 4);
                sg.g5.idx[i] = idx;
                if (idx !== -1) particles.iGroup[idx] = 43;
              }
            }

            const g5 = sg.g5;
            g5.t += dt;
            const water = g5.water;
            const vel = updateSuperGiant._tmpG5DropV || (updateSuperGiant._tmpG5DropV = new THREE.Vector3());
            const col = updateSuperGiant._tmpG5DropC || (updateSuperGiant._tmpG5DropC = new THREE.Color());
            const ndc = updateSuperGiant._tmpG5DropN || (updateSuperGiant._tmpG5DropN = new THREE.Vector3());
            const ndc2 = updateSuperGiant._tmpG5DropN2 || (updateSuperGiant._tmpG5DropN2 = new THREE.Vector3());
            const pDrop = updateSuperGiant._tmpG5DropP || (updateSuperGiant._tmpG5DropP = new THREE.Vector3());
            const bottomNdcY = -0.22;

            if (g5.phase === "meteor") {
              const uNow = clamp(g5.dur > 1e-6 ? g5.t / g5.dur : 1.0, 0, 1);
              const uNext = clamp(g5.dur > 1e-6 ? (g5.t + dtSafe) / g5.dur : 1.0, 0, 1);
              const sNow = uNow * uNow * (3 - 2 * uNow);
              const sNext = uNext * uNext * (3 - 2 * uNext);
              let aliveAny = false;
              for (let i = 0; i < g5.n; i++) {
                const idx = g5.idx[i];
                if (idx < 0 || !particles.alive[idx]) continue;
                aliveAny = true;
                const xNow = lerp(g5.sx[i], g5.ex[i], sNow);
                const yNow = lerp(g5.sy[i], g5.ey[i], sNow);
                const xNext = lerp(g5.sx[i], g5.ex[i], sNext);
                const yNext = lerp(g5.sy[i], g5.ey[i], sNext);
                const pNow = placeAt(xNow, yNow, g5.dist, _sevenTmp);
                const pNext = placeAt(xNext, yNext, g5.dist, _sevenTmp2);
                const b = idx * 3;
                particles.pos[b + 0] = pNow.x;
                particles.pos[b + 1] = pNow.y;
                particles.pos[b + 2] = pNow.z;
                particles.vel[b + 0] = (pNext.x - pNow.x) / Math.max(1e-6, dtSafe);
                particles.vel[b + 1] = (pNext.y - pNow.y) / Math.max(1e-6, dtSafe);
                particles.vel[b + 2] = (pNext.z - pNow.z) / Math.max(1e-6, dtSafe);
                if (uNow >= 1.0 && !g5.exploded[i]) {
                  g5.exploded[i] = 1;
                  if (!g5.secondaryPlayed && typeof soundManager !== 'undefined') {
                    g5.secondaryPlayed = 1;
                    soundManager.play('secondary', { force: true });
                  }
                  explodeAt(pNow, new THREE.Color("#f7fbff"), 6.0, 24, false, false, true, true);
                  particles.kill(idx);
                  g5.idx[i] = -1;
                }
              }

              if (water) {
                if (!water.lanes) {
                  water.lanes = Array.from({ length: g5.n }, (_, i) => i);
                }

                const spawnStep = 0.04;
                const targetS = clamp(sNow, 0, 1);
                let layers = Math.floor((targetS - water.lastS) / spawnStep);
                if (layers > 6) layers = 6;
                while (layers-- > 0 && uNow < 0.98) {
                  const ss = clamp(water.lastS + spawnStep, 0, 1);
                  water.lastS = ss;
                  if (water.dropIdx.length > 220) break;
                  for (let li = 0; li < water.lanes.length; li++) {
                    const i = water.lanes[li];
                    const xNow = lerp(g5.sx[i], g5.ex[i], ss);
                    const yNow = lerp(g5.sy[i], g5.ey[i], ss);
                    pDrop.copy(
                      placeAt(
                        clamp(xNow, -0.92, 0.92),
                        yNow,
                        g5.dist,
                        updateSuperGiant._tmpG5DropSpawn || (updateSuperGiant._tmpG5DropSpawn = new THREE.Vector3())
                      )
                    );
                    vel.set(rand(-0.03, 0.03) * s, rand(-7.2, -5.4) * s, 0);
                    col.setHSL(0.58 + rand(-0.04, 0.04), 0.22, 0.78);
                    const di = particles.spawnParticle(pDrop, vel, col, 9.2 / s, 0);
                    if (di !== -1) {
                      water.dropIdx.push(di);
                      water.dropLane.push(i);
                      // Water Drop Sound (Silent) - removed previous logic
                    }
                  }
                }
              }

              if (!aliveAny || g5.t > g5.dur + 0.55) {
                for (let i = 0; i < g5.n; i++) {
                  const idx = g5.idx[i];
                  if (idx >= 0 && particles.alive[idx]) particles.kill(idx);
                  g5.idx[i] = -1;
                }
                g5.phase = "charge";
                g5.t = 0;
                const y0 = -0.75;
                const pL = placeAt(-0.62, y0, g5.dist, _sevenTmp);
                const pR = placeAt(0.62, y0, g5.dist, _sevenTmp2);
                g5.lIdx = particles.spawnParticle(pL, new THREE.Vector3(0, 0, 0), g5.lCol, 7.5 / s, 4);
                g5.rIdx = particles.spawnParticle(pR, new THREE.Vector3(0, 0, 0), g5.rCol, 7.5 / s, 4);
                if (g5.lIdx !== -1) particles.iGroup[g5.lIdx] = 42;
                if (g5.rIdx !== -1) particles.iGroup[g5.rIdx] = 42;
                
                // G5 Charge Launch: 2x Launch (force: true)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('launch', { pitch: 1.0, force: true });
                   soundManager.play('launch', { pitch: 1.05, delay: 10, force: true });
                }
              }
            } else if (g5.phase === "charge") {
              const uNow = clamp(g5.chargeDur > 1e-6 ? g5.t / g5.chargeDur : 1.0, 0, 1);
              const uNext = clamp(g5.chargeDur > 1e-6 ? (g5.t + dtSafe) / g5.chargeDur : 1.0, 0, 1);
              const sNow = uNow * uNow * (3 - 2 * uNow);
              const sNext = uNext * uNext * (3 - 2 * uNext);
              const y0 = -0.75;
              const y1 = clamp(g5.baseY + 0.48, -0.05, 0.75);
              const yNow = lerp(y0, y1, sNow);
              const yNext = lerp(y0, y1, sNext);

              const pL = placeAt(-0.62, yNow, g5.dist, _sevenTmp);
              const pLN = placeAt(-0.62, yNext, g5.dist, _sevenTmp2);
              const pR = placeAt(0.62, yNow, g5.dist, updateSuperGiant._tmpG5R || (updateSuperGiant._tmpG5R = new THREE.Vector3()));
              const pRN = placeAt(0.62, yNext, g5.dist, updateSuperGiant._tmpG5R2 || (updateSuperGiant._tmpG5R2 = new THREE.Vector3()));

              if (g5.lIdx >= 0 && particles.alive[g5.lIdx]) {
                const b = g5.lIdx * 3;
                particles.pos[b + 0] = pL.x;
                particles.pos[b + 1] = pL.y;
                particles.pos[b + 2] = pL.z;
                particles.vel[b + 0] = (pLN.x - pL.x) / Math.max(1e-6, dtSafe);
                particles.vel[b + 1] = (pLN.y - pL.y) / Math.max(1e-6, dtSafe);
                particles.vel[b + 2] = (pLN.z - pL.z) / Math.max(1e-6, dtSafe);
              }
              if (g5.rIdx >= 0 && particles.alive[g5.rIdx]) {
                const b = g5.rIdx * 3;
                particles.pos[b + 0] = pR.x;
                particles.pos[b + 1] = pR.y;
                particles.pos[b + 2] = pR.z;
                particles.vel[b + 0] = (pRN.x - pR.x) / Math.max(1e-6, dtSafe);
                particles.vel[b + 1] = (pRN.y - pR.y) / Math.max(1e-6, dtSafe);
                particles.vel[b + 2] = (pRN.z - pR.z) / Math.max(1e-6, dtSafe);
              }

              if (uNow >= 1.0 || g5.t > g5.chargeDur + 0.25) {
                g5.tmpL.copy(pL);
                g5.tmpR.copy(pR);
                
                // Stop G5 Water Loop
                if (g5.water && g5.water.secondaryLoopId && typeof soundManager !== 'undefined') {
                   soundManager.stopLoop(g5.water.secondaryLoopId);
                   g5.water.secondaryLoopId = 0;
                }
                
                if (g5.lIdx >= 0) particles.kill(g5.lIdx);
                if (g5.rIdx >= 0) particles.kill(g5.rIdx);
                g5.lIdx = -1;
                g5.rIdx = -1;
                
                // G5 Big Explode: 2x Giant (10ms) + Secondary (1.5s)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('giant', { pitch: 0.9, force: true });
                   soundManager.play('giant', { pitch: 0.95, delay: 10, force: true });
                   soundManager.play('secondary', { volume: 0.6, delay: 1500, force: true });
                }

                explodeAt(g5.tmpL, g5.lCol, 42.0, 1600, true, 2, false, true);
                explodeAt(g5.tmpR, g5.rCol, 42.0, 1600, true, 2, false, true);
                g5.phase = "core";
                g5.t = 0;
              }
            } else if (g5.phase === "core") {
              if (g5.t > 0.35) {
                const cY = clamp(g5.baseY + 0.36, -0.1, 0.7);
                const p = placeAt(0, cY, g5.dist, updateSuperGiant._tmpG5C || (updateSuperGiant._tmpG5C = new THREE.Vector3()));
                
                // G5 Core Explode: Giant + Secondary (1.5s)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('giant', { force: true });
                   soundManager.play('secondary', { delay: 1500, force: true });
                }
                
                explodeAt(p, new THREE.Color("#ffffff"), 22.0, 260, true, 1, true, true);
                sg.phase = "g5_after";
                sg.phaseT = 0;
                sg.lastExplodeT = t;
              }
            }

            if (water && water.dropIdx.length) {
              if (!water.lanes) {
                water.lanes = Array.from({ length: g5.n }, (_, i) => i);
              }
              const n = water.dropIdx.length;
              if (!water._lanePick || water._lanePick.length !== g5.n) water._lanePick = new Int32Array(g5.n);
              if (!water._lanePickY || water._lanePickY.length !== g5.n) water._lanePickY = new Float32Array(g5.n);
              water._lanePick.fill(-1);
              for (let li = 0; li < g5.n; li++) water._lanePickY[li] = 1e9;

              let candL = 0;
              let candR = 0;
              let aliveL = 0;
              let aliveR = 0;

              for (let k = 0; k < n; k++) {
                const di = water.dropIdx[k];
                if (di < 0 || !particles.alive[di] || particles.kind[di] !== 0) {
                  water.dropIdx[k] = -1;
                  continue;
                }
                const lane = (water.dropLane[k] | 0) || 0;
                if (lane < 0 || lane >= g5.n) continue;
                const b = di * 3;
                ndc.set(particles.pos[b + 0], particles.pos[b + 1], particles.pos[b + 2]).project(camera);
                if (ndc.z < -1 || ndc.z > 1) continue;
                if (ndc.x < 0) aliveL++;
                else aliveR++;
                const vyNow = particles.vel[b + 1];
                if (vyNow < -0.5) {
                  const nx = particles.pos[b + 0] + particles.vel[b + 0] * dtSafe;
                  const ny = particles.pos[b + 1] + vyNow * dtSafe;
                  const nz = particles.pos[b + 2] + particles.vel[b + 2] * dtSafe;
                  ndc2.set(nx, ny, nz).project(camera);
                  const crossed = ndc.y > bottomNdcY && ndc2.y <= bottomNdcY;
                  if (!(ndc.y <= bottomNdcY || crossed)) continue;
                  if (ndc.x < 0) candL++;
                  else candR++;
                  if (ndc.y < water._lanePickY[lane]) {
                    water._lanePickY[lane] = ndc.y;
                    water._lanePick[lane] = k;
                  }
                }
              }

              let pickL = 0;
              let pickR = 0;
              for (let lane = 0; lane < g5.n; lane++) {
                const k = water._lanePick[lane];
                if (k < 0) continue;
                const di = water.dropIdx[k];
                if (di < 0 || !particles.alive[di] || particles.kind[di] !== 0) {
                  water.dropIdx[k] = -1;
                  continue;
                }
                const b = di * 3;
                ndc.set(particles.pos[b + 0], particles.pos[b + 1], particles.pos[b + 2]).project(camera);
                if (ndc.z < -1 || ndc.z > 1) continue;
                const p = updateSuperGiant._tmpG5DropExplode || (updateSuperGiant._tmpG5DropExplode = new THREE.Vector3());
                p.set(particles.pos[b + 0], particles.pos[b + 1], particles.pos[b + 2]);
                
                // Water Drop Explode Sound: 20% Signal
                if (typeof soundManager !== 'undefined') {
                   if (Math.random() < 0.2) {
                       soundManager.play('singal', { force: true });
                   }
                }

                explodeAt(p, new THREE.Color("#eaf2ff"), 11.0, 120, false, false, false, false);
                particles.kill(di);
                water.dropIdx[k] = -1;
                
                // G5 Water Impact Sound Loop (Manual) - REMOVED
                
                if (ndc.x < 0) {
                  water.exL++;
                  pickL++;
                } else {
                  water.exR++;
                  pickR++;
                }
                if (ndc.x < water.exMinX) water.exMinX = ndc.x;
                if (ndc.x > water.exMaxX) water.exMaxX = ndc.x;
              }

              water.dbgAliveL = aliveL;
              water.dbgAliveR = aliveR;
              water.dbgCandL = candL;
              water.dbgCandR = candR;
              water.dbgPickL = pickL;
              water.dbgPickR = pickR;
              water.explodeCursor = (water.explodeCursor + 1) % Math.max(1, n);
              let w = 0;
              for (let k = 0; k < water.dropIdx.length; k++) {
                const di = water.dropIdx[k];
                if (di !== -1) {
                  water.dropIdx[w] = di;
                  water.dropLane[w] = water.dropLane[k];
                  w++;
                }
              }
              water.dropIdx.length = w;
              water.dropLane.length = w;
              
              // Manual Secondary Loop for Water Phase - REMOVED
            }
          } else if (sg.phase === "g5_after") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            // g5: 瀑布流，底部爆发
            // Delay increased to 4.5s to let waterfall effect play out
            if (!sg.g5Text && sg.phaseT > 4.5) {
              sg.g5Text = 1;
              const g5 = sg.g5;
              const cY = clamp(g5.baseY + 0.36, -0.1, 0.7);
              const pCenter = placeAt(0, cY, g5.dist).clone();
              
              // Capture active firework particles
              const srcParticles = captureActiveParticles(4000);
              killActiveParticles();
              
              const items = generateBlessingItems(pCenter);
              triggerBlessingTexts(items, srcParticles, 2.25); 
            }
            if (!sg.g5Wind && sg.phaseT > 8.5) { // Extended duration: 4.5 -> 8.5 (Show ~4.0s)
              sg.g5Wind = 1;
              triggerBlessingDissolve();
            }
            if (sg.phaseT > 11.5) { // Extended total: 9.5 -> 11.5
              sg.phase = "final_wait";
              sg.phaseT = 0;
              stopMorphImmediately();
            }
          } else if (sg.phase === "final_wait") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const dtSafe = clamp(dt, 0, 0.05);
            const placeAt = (xNdc, yNdc, dist, out) => {
              const o = out || _sevenTmp;
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return o.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g6) {
              const dist = 62.0;
              const cfg = computeSevenLayout(dist, 4.0, 0.80);
              const baseY = clamp(cfg.yNdc + 0.02, -0.25, 0.5);
                sg.g6 = {
                  phase: "main",
                  t: 0,
                  dist,
                  baseY,
                  center: new THREE.Vector3(),
                  petalDone: 0,
                  microDone: 0,
                };
                const cY = clamp(baseY + 0.35, -0.05, 0.75);
                sg.g6.center.copy(placeAt(0, cY, dist, _sevenTmp));
                
                // G6 Launch: REMOVED
                
                // G6 Big Explode: Giant + Secondary (force: true)
                if (typeof soundManager !== 'undefined') {
                   soundManager.play('giant', { pitch: 0.9, force: true });
                   // User Request: Secondary after giant + 1.5s
                   soundManager.play('secondary', { volume: 0.6, delay: 1500, force: true });
                }
                
                explodeAt(sg.g6.center, new THREE.Color("#ff6ad5"), 40.0, 1500, true, 2, false, true);
              }

            const g6 = sg.g6;
            g6.t += dt;

            if (g6.phase === "main") {
              if (!g6.petalDone && g6.t > 0.48) {
                g6.petalDone = 1;
                const petalN = 14;
                const r = 0.28;
                const cY = clamp(g6.baseY + 0.35, -0.05, 0.75);
                for (let i = 0; i < petalN; i++) {
                  const th = (i / petalN) * Math.PI * 2;
                  const x = Math.cos(th) * r;
                  const y = cY + Math.sin(th) * r * 0.74;
                  const p = placeAt(x, y, g6.dist, updateSuperGiant._tmpG6P || (updateSuperGiant._tmpG6P = new THREE.Vector3()));
                  
                  // G6 Petal: Reuse G4 Logic (1x Secondary + 5x Signal)
                  // petalN = 14 (i: 0-13)
                  if (typeof soundManager !== 'undefined') {
                     // 1. One Secondary at center (i=7)
                     if (i === 7) {
                         soundManager.play('secondary', { force: true });
                     }
                     // 2. Five Signals (0, 3, 6, 9, 12)
                     if (i % 3 === 0) {
                         soundManager.play('singal', { delay: randInt(0, 150), force: true });
                     }
                  }

                  explodeAt(p, new THREE.Color("#63f4ff"), 14.0, 220, false, false, false, true);
                }
              }
              if (!g6.microDone && g6.t > 1.05) {
                g6.microDone = 1;
                const cY = clamp(g6.baseY + 0.35, -0.05, 0.75);
                for (let i = 0; i < 9; i++) {
                  const th = rand(0, Math.PI * 2);
                  const rr = rand(0.06, 0.22);
                  const x = Math.cos(th) * rr;
                  const y = cY + Math.sin(th) * rr * 0.9;
                  const p = placeAt(x, y, g6.dist, updateSuperGiant._tmpG6M || (updateSuperGiant._tmpG6M = new THREE.Vector3()));
                  
                  // G6 Micro: 3x Signal (random interval)
                  // Total 9 particles. Trigger for first 3 (i < 3)
                  if (typeof soundManager !== 'undefined' && i < 3) {
                      soundManager.play('singal', { delay: randInt(0, 100), force: true });
                  }
                  
                  explodeAt(p, new THREE.Color("#ffffff"), 9.0, 90, false, false, false, true);
                }
              }
              if (g6.t > 1.45) {
                const p = placeAt(0, clamp(g6.baseY + 0.78, 0.2, 0.86), g6.dist, updateSuperGiant._tmpG6F || (updateSuperGiant._tmpG6F = new THREE.Vector3()));
                
                // G6 Final: Sound REMOVED
                
                explodeAt(p, new THREE.Color("#f6ffff"), 12.0, 140, false, false, false, true);
                sg.phase = "g6_after";
                sg.phaseT = 0;
                sg.lastExplodeT = t;
              }
            }
          } else if (sg.phase === "g6_after") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g6Text && sg.phaseT > 0.1) {
              sg.g6Text = 1;
              const g6 = sg.g6;
              const pCenter = placeAt(0, clamp(g6.baseY + 0.78, 0.2, 0.86), g6.dist).clone();
              
              // Capture active firework particles
              const srcParticles = captureActiveParticles(3000);
              killActiveParticles();
              
              const items = generateBlessingItems(pCenter);
              triggerBlessingTexts(items, srcParticles);
            }
            // Restore g6Wind dissolve
            if (!sg.g6Wind && sg.phaseT > 4.5) { // Extended duration: 0.1 -> 4.5 (Show ~4.4s)
              sg.g6Wind = 1;
              triggerBlessingDissolve();
            }
            if (sg.phaseT > 7.5) { // Extended total: 4.5 -> 7.5
              sg.phase = "g7";
              sg.phaseT = 0;
              sg.g7 = null;
            }
          } else if (sg.phase === "g7") {
            if (!camera) return;
            camera.updateMatrixWorld(true);
            const cam = camera.position;
            const placeAt = (xNdc, yNdc, dist) => {
              _sevenNdc.set(xNdc, yNdc, 0.5).unproject(camera);
              _sevenRay.copy(_sevenNdc).sub(cam);
              const d = _sevenRay.length();
              if (d > 1e-6) _sevenRay.multiplyScalar(1.0 / d);
              else _sevenRay.set(0, 0, -1);
              return _sevenTmp.copy(cam).addScaledVector(_sevenRay, dist);
            };

            if (!sg.g7) {
              // Recalculate center position to match g6 text location
              const dist = 62.0;
              const cfg = computeSevenLayout(dist, 4.0, 0.80);
              const baseY = clamp(cfg.yNdc + 0.02, -0.25, 0.5);
              const centerY = clamp(baseY + 0.78, 0.2, 0.86);
              const pCenter = placeAt(0, centerY, dist).clone();

              sg.g7 = {
                phase: "gather",
                t: 0,
                center: pCenter
              };
              
              // Reset morph state to allow gathering from scattered positions
              morph.gravityDissolve = false;
              morph.windActive = false;
              morph.locked = false;
              morph.frozen = false;
              morph.useDots = true; // Ensure dots for gathering
              morph.mesh.visible = false;
              morph.dotMesh.visible = true;
              morph.active = true;
              
              // Set all morph targets to center for gathering effect
              const n = morph.liveCount || 0;
              for(let i=0; i<n; i++) {
                 const b3 = i*3;
                 morph.target[b3+0] = pCenter.x;
                 morph.target[b3+1] = pCenter.y;
                 morph.target[b3+2] = pCenter.z;
                 
                 // Reset physics state
                 morph.vel[b3+0] *= 0.1; // Dampen existing velocity
                 morph.vel[b3+1] *= 0.1;
                 morph.vel[b3+2] *= 0.1;
                 
                 // Ensure visible
                 morph.alpha[i] = 1.0;
                 morph.width[i] = morph.baseWidth[i] * 1.5; // Thicker for visibility
                 
                 // Reset delay to ensure immediate response
                 morph.delay[i] = 0;
                 // Increase breathing speed for excitement
                 morph.breatheSpeed[i] = 4.0;
              }
              // Force updates
              morph.geom.attributes.iHead.needsUpdate = true;
              morph.geom.attributes.iTail.needsUpdate = true;
              morph.geom.attributes.iDelay.needsUpdate = true;
              morph.geom.attributes.iAlpha.needsUpdate = true;
              morph.geom.attributes.iWidth.needsUpdate = true;
            }
            
            const g7 = sg.g7;
            g7.t += dt;
            
            if (g7.phase === "gather") {
               // Stronger pull to center
               // We need to override updateMorph physics slightly or just rely on spring
               // Default spring is strong enough (baseSpring=18.0)
               
               // Wait for gather (1.2s)
               if (g7.t > 1.2) {
                  g7.phase = "bang";
                  g7.t = 0;
                  
                  // Hide morph particles
                  stopMorphImmediately();
                  
                  // BIG BANG
                  // Huge white explosion at center
                  explodeAt(g7.center, new THREE.Color("#ffffff"), 60.0, 2500, true, 2, true, true);
                  
                  // G7 Final Big Bang: 2x Giant + 2x Secondary (Delayed)
                  if (typeof soundManager !== 'undefined') {
                     soundManager.play('giant', { force: true });
                     soundManager.play('giant', { delay: 20, force: true });
                     soundManager.play('secondary', { delay: 1500, force: true });
                     soundManager.play('secondary', { delay: 1800, force: true });
                  }
                  
                  // Add some colorful secondary rings
                  explodeAt(g7.center, new THREE.Color("#ffcc66"), 45.0, 800, true, 0, false, true);
                  explodeAt(g7.center, new THREE.Color("#63f4ff"), 30.0, 600, true, 0, false, true);
                  
                  sg.lastExplodeT = t;
               }
            } else if (g7.phase === "bang") {
               if (g7.t > 9.5) { // Delay increased from 6.5 to 9.5 to wait for dissipation
                  stageState._superGiant = null;
                  startLongTextSequence();
               }
            }
          }
        }

        function startStage6Blessing() {
          stageState.stage = 6;
          stageState.stageT = 0;
          stageState.finaleT = 0;
          resetMorphText(true);
          assignFinaleTextTargetsNew();
          stageState._morphBillboardBakedStage = 0;
          updateMorphBillboard();
          const n = morph.liveCount || 0;
          
          // Revert scatter logic to original
          for (let i = 0; i < n; i++) {
            const b3 = i * 3;
            const tx = morph.target[b3 + 0];
            const ty = morph.target[b3 + 1];
            const tz = morph.target[b3 + 2];

            // Revert scatter radius to +/- 8.0 (matches previous version)
            morph.pos[b3 + 0] = tx + rand(-8.0, 8.0);
            morph.pos[b3 + 1] = ty + rand(-8.0, 8.0);
            morph.pos[b3 + 2] = tz + rand(-8.0, 8.0);
            morph.vel[b3 + 0] = rand(-2.0, 2.0);
            morph.vel[b3 + 1] = rand(-2.0, 2.0);
            morph.vel[b3 + 2] = rand(-2.0, 2.0);
            
            morph.head[b3 + 0] = morph.pos[b3 + 0];
            morph.head[b3 + 1] = morph.pos[b3 + 1];
            morph.head[b3 + 2] = morph.pos[b3 + 2];
            morph.tail[b3 + 0] = morph.pos[b3 + 0];
            morph.tail[b3 + 1] = morph.pos[b3 + 1];
            morph.tail[b3 + 2] = morph.pos[b3 + 2];
            
            // Revert: Alpha should be set to target alpha initially, not 0
            // Because updateMorph in Stage 6 handles fade-in differently (via groupReveal)
            morph.alpha[i] = morph.baseAlpha[i];
            morph.width[i] = morph.baseWidth[i];
          }
          morph.geom.attributes.iHead.needsUpdate = true;
          morph.geom.attributes.iTail.needsUpdate = true;
          morph.geom.attributes.iAlpha.needsUpdate = true;
          morph.geom.attributes.iWidth.needsUpdate = true;
          
          if (controls) {
            controls.minPolarAngle = 0.1;
            controls.maxPolarAngle = Math.PI - 0.1;
            controls.enablePan = false;
            controls.enableZoom = true;
            controls.enableRotate = true;
            controls.autoRotate = false;
            controls.update();
          }
        }

        function updateStages(dt, t) {
          stageState.stageT += dt;
          if (stageState.stage === 1) return;

          if (stageState.stage === 2) {
            countdown.t += dt;
            if (countdown.current) {
              // Unify rotation: Constant slow rotation, fixed X angle
              countdown.current.rotation.y += dt * 0.5; 
              countdown.current.rotation.x = 0.15; 
            }
            const second = CONFIG.stage.countdownSeconds - Math.floor(stageState.stageT);
            if (second !== stageState.countdownShown && second > 0) {
              stageState.countdownShown = second;
              setCountdownDigit(second);
              countdown.group.scale.setScalar(1.25);
              
              // Play countdown sound for this second
              if (typeof soundManager !== 'undefined') {
                 // Keys: c5, c4, c3, c2, c1
                 if (second >= 1 && second <= 5) {
                    soundManager.play('c' + second, { force: true });
                 }
              }
            }
            countdown.group.scale.setScalar(lerp(countdown.group.scale.x, 1.0, 1 - Math.pow(0.0009, dt)));
            if (stageState.stageT >= CONFIG.stage.countdownSeconds) {
              hideCountdown();
              startIntroTextSequence();
            }
          } else if (stageState.stage === 25) {
             // Intro Text Sequence
             const t = stageState.stageT;
             
             // User Request: Play intro audio "Hey"
             // Play it right at the start (Phase 0)
             if (t < 0.1 && !stageState._introHeyPlayed) {
                 stageState._introHeyPlayed = true;
                 if (typeof soundManager !== 'undefined') {
                     soundManager.play('hey', { force: true });
                 }
             }
             
             // User Request: Shorten intro times by 10%
             // Old: 1.2 -> 1.08
             // Old: 1.44 -> 1.30
             // Old: 3.84 -> 3.46
             // Old: 4.4 -> 3.96

             // Phase 0: Hey! (0 - 1.08s)
             if (stageState.introPhase === 0 && t > 1.08) {
                stageState.introPhase = 1;
                hideIntroText();
             }
             
             // Phase 1: Gap (1.08 - 1.30s) -> Show HNY
              if (stageState.introPhase === 1 && t > 1.30) {
                 stageState.introPhase = 2;
                 showIntroText("Happy New Year!", { 
                    fontSize: 100, 
                    scale: 0.75, 
                    color: "#7DF9FF", 
                    shadow: "rgba(0,255,255,0.6)" 
                 });
                 // User Request: Play "Happyny.m4a" when HNY appears
                 if (typeof soundManager !== 'undefined') {
                     soundManager.play('happyny', { force: true });
                 }
              }
             
             // Phase 2: HNY (1.30 - 3.46s)
             if (stageState.introPhase === 2 && t > 3.46) {
                stageState.introPhase = 3;
                hideIntroText();
             }
             
             // Phase 3: Gap (3.46 - 3.96s) -> Start Show
             if (stageState.introPhase === 3 && t > 3.96) {
                startSparkAndBlast();
             }
          } else if (stageState.stage === 8) {
             // Long text sequence, controlled by timeouts in startLongTextSequence
          } else if (stageState.stage === 3) {
            spark.t += dt;
            if (spark.active && spark.idx >= 0) {
              const b = spark.idx * 3;
              const head = new THREE.Vector3(particles.pos[b + 0], particles.pos[b + 1], particles.pos[b + 2]);
              const tail = new THREE.Vector3(0, -1.2, 0);
              // pushWordsFromLine(dt, 22.0, head, tail);
              // repelWordsField(dt, head, 3.65, 92.0);

              // Audio Pre-trigger (User Request: 0.4s before explosion)
               // FIXED LOGIC: Trigger based on Height Percentage to ensure early enough playback.
               // Apex is approx 8.0 to 15.0 depending on random. Spark target is usually fixed around 15.0 in explodeAt logic?
               // Wait, in Stage 3, explodeAt(head...) is called when head.y >= apex.
               // Let's trigger when we are at 60% of the way up.
               const currentY = head.y;
               const targetY = spark.apex ? spark.apex.y : 8.0;
               
               // Pre-fade logic: Trigger fade out when reaching 30% of target height (much earlier)
               // Use requestAnimationFrame for smoother fade
               if (!spark._fadeTriggered && currentY > targetY * 0.30 && spark._launchAudio) {
                   spark._fadeTriggered = true;
                   const audio = spark._launchAudio;
                   // Adjust fade duration: 
                   // Flight time is approx 2.0s to 2.5s. Launch audio is longer.
                   // Starting fade at 30% height leaves about 1.4s of flight time.
                   // Let's fade over 1.8s to ensure it's fully gone by apex.
                   const fadeDuration = 1800; 
                   const startVol = audio.volume;
                   const startTime = nowMs();
                   
                   const tickFade = () => {
                      if (!audio || !spark._fadeTriggered) return; // Stopped elsewhere
                      const elapsed = nowMs() - startTime;
                      const progress = Math.min(1.0, elapsed / fadeDuration);
                      // Ease out cubic
                      const alpha = 1.0 - Math.pow(progress, 3); 
                      
                      try {
                          audio.volume = Math.max(0, startVol * alpha);
                          if (progress < 1.0 && audio.volume > 0.01) {
                             requestAnimationFrame(tickFade);
                          } else {
                             audio.pause();
                             audio.currentTime = 0;
                             audio._busy = false;
                          }
                      } catch(e) {}
                   };
                   requestAnimationFrame(tickFade);
               }
               


              if (head.y >= (spark.apex ? spark.apex.y : 8.0) || spark.t > (spark._dur || spark.duration) * 0.96) {
                spark.active = false;
                if (spark.idx >= 0) {
                  particles.kill(spark.idx);
                  spark.idx = -1;
                }
                const boomColor = new THREE.Color("#ffcf62");
                // 第一束烟花：巨型模式，爆炸范围覆盖70%屏幕 (isGiant=true)
                // playSound depends on if triggered

                // Ensure stopped if not already (cleanup)
                if (spark._launchAudio) {
                   try {
                      const audio = spark._launchAudio;
                      audio.pause();
                      audio.currentTime = 0;
                      audio._busy = false;
                      spark._launchAudio = null;
                   } catch(e) {}
                }

                // explodeAt(head, boomColor, 15.0 * 2.0, randInt(700, 980), true, true, !spark._soundTriggered);
                // Manual sound trigger for first firework (giant)
                if (!spark._soundTriggered && typeof soundManager !== 'undefined') {
                   // User Request: G1 three explosions use 'giant' sound
                   // This is the first explosion of the first sequence.
                   // The subsequent text explosions are handled in blastWordsOut -> updateWords.
                   // But here we are just exploding the spark.
                   // Let's ensure this initial blast uses 'giant'.
                   soundManager.play('giant', { force: true, volume: 1.0 });
                   // User Request: Add secondary sound delayed by 1.0s for the first firework
                   soundManager.play('secondary', { force: true, delay: 1000 });
                   spark._soundTriggered = true;
                }
                // Pass soundType: 'giant' explicitly to explodeAt for consistency with G1 request
                explodeAt(head, boomColor, 15.0 * 2.0, randInt(700, 980), true, true, false, true, 'giant');
                if (!stageState._firstFireworkScaled) {
                  stageState._firstFireworkScaled = true;
                  // setRootScale(0.90); // Reverted to avoid black borders
                  setRootScale(1.0);
                }
                blastWordsOut(head);
                
                // User Request: Play sun.m4a with sun.srt subtitles after secondary explosion (first firework)
                if (typeof soundManager !== 'undefined') {
                    setTimeout(() => {
                        const style = { bottom: '10%', fontSize: '28px' };
                        const EMBED_SUN_SRT = `1
00:00:01,040 --> 00:00:03,650
人类需要很多很多晴天和阳光
Human beings need many, many sunny days and sunshine

2
00:00:03,750 --> 00:00:06,090
去晒干过往的雨滴和潮湿
Go dry the past raindrops and dampness

3
00:00:06,850 --> 00:00:08,100
如果可以
If possible

4
00:00:08,470 --> 00:00:09,310
我想
I think

5
00:00:09,830 --> 00:00:11,310
当我睁开双眼
When I open my eyes

6
00:00:11,970 --> 00:00:13,700
阳光连同幸福
Sunshine accompanied by happiness

7
00:00:14,710 --> 00:00:16,510
一起穿过我的瞳孔
Let's go through my pupils together`;

                        const EMBED_TIM_SRT = `1
00:00:00,540 --> 00:00:02,100
我不知道我在做什么  以前我起床
I don't know what I was doing before I got up.

2
00:00:02,100 --> 00:00:03,320
我会觉得  哇  今天我要努力
I would feel like, "Wow, I'm going to work hard today!"

3
00:00:03,320 --> 00:00:04,960
去把这个视频做出来  我
Go and make this video.

4
00:00:04,960 --> 00:00:06,600
之前都要忙这件事情  但是
I was busy with this matter before, but when

5
00:00:06,600 --> 00:00:08,000
当你同时做30个事情的时候
When you do 30 things at the same time

6
00:00:08,000 --> 00:00:10,720
你会发现  我今天是要
You'll find that I'm going to...

7
00:00:10,720 --> 00:00:11,980
为什么东西而努力
What are we striving for?

8
00:00:11,980 --> 00:00:13,660
来着这感觉特别  特别
This feeling is especially special.

9
00:00:13,660 --> 00:00:15,239
糟糕  反正这次来
Oh well, anyway, what's the purpose of this visit?

10
00:00:15,239 --> 00:00:17,780
意大利我觉得挺好的一点就是
One of the good things about Italy, in my opinion, is that it's old.

11
00:00:17,780 --> 00:00:19,800
老外他缺点有很多  这个我就
He has many shortcomings, that's all.

12
00:00:19,800 --> 00:00:21,400
不过多赘述  但是有一点
However, I won't go into too much detail, but there is one point...

13
00:00:21,400 --> 00:00:23,160
我真的觉得挺值得学的
I really think it's worth learning.

14
00:00:23,160 --> 00:00:25,660
就是他们从来不为自己的
They never think of themselves

15
00:00:25,660 --> 00:00:27,800
休息而有愧疚感  这个
Feeling guilty while resting

16
00:00:27,800 --> 00:00:29,820
是一个我觉得很难一点  比如其实
It's something I find a bit difficult, for example...

17
00:00:29,820 --> 00:00:31,439
我们比较忙特别高强度
We are quite busy and extremely stressed.

18
00:00:31,439 --> 00:00:32,980
的工作环境之下
Under the influence of a high degree of working environment

19
00:00:32,980 --> 00:00:34,840
经常会想  我这样会不会被
I often wonder if I'll be...

20
00:00:34,840 --> 00:00:36,100
别人超过  我这样休息
Others rest like me

21
00:00:36,100 --> 00:00:38,160
真的可以吗  我这样休息
Is it really okay for me to rest like this for a while?

22
00:00:38,160 --> 00:00:39,280
会不会让别的同事觉得
It won't make other colleagues feel uncomfortable.

23
00:00:39,280 --> 00:00:40,940
不可靠  但是我和这些
Reliable, but I and these old ones

24
00:00:40,940 --> 00:00:42,860
老外聊天  他们就会说  Tim
When they chat outside, they'll say Tim

25
00:00:42,860 --> 00:00:45,080
你累吗  然后我说  确实
Are you tired? Then you said yes.

26
00:00:45,080 --> 00:00:47,800
有点累   他说  那  你  休息啊
He said you should rest if you're tired.

27
00:00:47,800 --> 00:00:49,380
反正对他们来说  是个
Anyway, it's a...

28
00:00:49,380 --> 00:00:50,700
很自然的事情  就这种
It's just a natural thing.

29
00:00:50,700 --> 00:00:52,120
松弛感  我知道这和他们的生活
I know about relaxation and their lives.

30
00:00:52,120 --> 00:00:53,860
环境  他们的生活状态和
Their living conditions and environment

31
00:00:53,860 --> 00:00:55,140
收入什么各方面很大的
Income and other aspects are very important.

32
00:00:55,140 --> 00:00:57,420
关系但是讲真的  我还是挺
But honestly, I'm still quite envious.

33
00:00:57,420 --> 00:00:59,880
羡慕的  就是  你看  他们在休息
I admire them because they are resting.

34
00:01:00,460 --> 00:01:03,220
他们在休息  这里的鸭子
The ducks are resting here.

35
00:01:03,220 --> 00:01:05,380
也在休息  反正我希望
I'm also resting, anyway, I hope

36
00:01:05,380 --> 00:01:08,400
我们大家就是该休息的时候  如果
It's time for us all to rest.

37
00:01:08,400 --> 00:01:10,260
身体觉得累了  那咱就
If your body feels tired, then we'll...

38
00:01:10,260 --> 00:01:11,800
歇上一些也不打紧
It's okay to take a break.`;

                        const EMBED_SILENCE_SRT = `1
00:00:00,160 --> 00:00:01,200
我喜欢这里的寂静
I like the silence

2
00:00:02,080 --> 00:00:02,800
它让我感到安慰
It's comforting

3
00:00:04,800 --> 00:00:09,120
这让我意识到  你真的处于自己生活的中心
And it made me realize that you are really at the center of your own life

4
00:00:11,120 --> 00:00:13,920
你真的能控制自己的生活
You are really in control of your own life

5
00:00:15,520 --> 00:00:20,960
所以  无论你在生活中做什么  无论你正走上哪条路
So  whatever you are doing in life  whatever path you may be going down

6
00:00:22,240 --> 00:00:25,240
你要明白  你随时可以改变那条路
just realize that you can change that path at any time`;

                        const loadSrtText = (url, fallback) => {
                          return fetch(url)
                            .then((r) => r.text())
                            .catch(() => Promise.resolve(fallback));
                        };
                        const playWithSrt = (key, url, fallback) => {
                          return loadSrtText(url, fallback).then((txt) => {
                            const subs = soundManager.parseSRT(txt);
                            return soundManager.playAudioWithSubtitles(key, subs, style);
                          });
                        };

                        playWithSrt('sun', `subtitles/sun.srt?ts=${Date.now()}`, EMBED_SUN_SRT).then((sunAudio) => {
                          if (!sunAudio || typeof sunAudio.addEventListener !== 'function') return;
                          sunAudio.addEventListener(
                            'ended',
                            () => {
                              setTimeout(() => {
                                playWithSrt('tim', `subtitles/tim.srt?ts=${Date.now()}`, EMBED_TIM_SRT).then((timAudio) => {
                                  if (!timAudio || typeof timAudio.addEventListener !== 'function') return;
                                  timAudio.addEventListener(
                                    'ended',
                                    () => {
                                      setTimeout(() => {
                                        playWithSrt('silence', `subtitles/silence.srt?ts=${Date.now()}`, EMBED_SILENCE_SRT);
                                      }, 1500);
                                    },
                                    { once: true }
                                  );
                                });
                              }, 1500);
                            },
                            { once: true }
                          );
                        });
                    }, 1500);
                }

                stageState.stage = 4;
                stageState.stageT = 0;
                stageState.fireworksT = 0;
                
                // 修复第一次卡顿：计算当前相机角度，实现无缝切换到自动旋转轨道
                const dx = camera.position.x;
                const dz = camera.position.z;
                const currentAngle = Math.atan2(dz, dx);
                // 目标公式是 a = t * 0.072 + offset (速度减缓40%，0.12 * 0.6 = 0.072)
                // 所以 offset = currentAngle - t * 0.072
                stageState.camOffsetAngle = currentAngle - t * 0.072;

                stageState._camEnterPos = camera.position.clone();
                stageState._camEnterTarget = controls ? controls.target.clone() : new THREE.Vector3(0, 0, 0);
                stageState._camEnterDur = 0.85;
                
                // 平滑过渡 target (可选，暂时保持直接切换，优先解决位置跳变)
                // controls.target.set(0, 2.0, 0); 
              }
            }
          } else if (stageState.stage === 4) {
            stageState.fireworksT += dt;
            
            // 实现烟花燃放频率曲线：渐强 -> 高潮 -> 渐弱
            const ft = stageState.fireworksT;
            const total = CONFIG.stage.fireworksSeconds;
            
            // 如果超过预定时间，进入"安可"阶段（Extra Finale）然后停止发射
            if (ft >= total) {
              const extraDuration = 4.5; // 4.5s for ~10 extra fireworks
              const extraT = ft - total;
              
              if (extraT < extraDuration) {
                  // User Request: Add 10 extra fireworks at the very end with dense-sparse-very sparse rhythm.
                  let rateFactor = 0;
                  
                  // Phase 1: Dense (0 - 1.0s) -> ~7 rockets
                  if (extraT < 1.0) {
                      rateFactor = 2.2; 
                      stageState.soundMinGap = 50;
                      stageState.soundMaxGap = 120;
                  } 
                  // Phase 2: Sparse (1.0 - 2.5s) -> ~2-3 rockets
                  else if (extraT < 2.5) {
                      rateFactor = 0.5; 
                      stageState.soundMinGap = 400;
                      stageState.soundMaxGap = 800;
                  }
                  // Phase 3: Very Sparse (2.5 - 4.5s) -> ~1 rocket
                  else {
                      rateFactor = 0.15; 
                      stageState.soundMinGap = 1000;
                      stageState.soundMaxGap = 2000;
                  }
                  
                  stageState._rocketAcc = (stageState._rocketAcc || 0) + dt * CONFIG.fireworks.rocketsPerSecond * rateFactor;
                  while (stageState._rocketAcc > 1) {
                      stageState._rocketAcc -= 1;
                      spawnRocket(t, 0.9, Math.random() < 0.5, false);
                  }
                  
              } else {
                  // 进入等待消散阶段
                  let activeParticles = 0;
                  for(let i=0; i<particles.max; i++) {
                     if (particles.alive[i]) activeParticles++;
                  }
                  
                  const waitTime = extraT - extraDuration;
                  if (activeParticles < 100 || waitTime > 1.5) { 
                     startFinale();
                  }
              }
            } else {
               // Adjusted Ratios for Symmetry: 30% RampUp, 40% Climax, 30% RampDown
               const rampUp = total * 0.3; 
               const climax = total * 0.4; 
               const rampDown = total * 0.3; 
               
               let rateFactor = 0;
               if (ft < rampUp) {
                 // 渐强阶段 (Sparse)
                 rateFactor = lerp(0.5, 1.2, ft / rampUp);
                 // Audio: Sparse but allow burst
                 stageState.soundMinGap = 60;
                 stageState.soundMaxGap = 200;
               } else if (ft < rampUp + climax) {
                 // Climax Phase: Sustain - Interval Pattern
                 // Sustain (Dense) -> Interval (Transition) -> Sustain -> ...
                 const ct = ft - rampUp;
                 // Total Climax ~9.2s (23 * 0.4)
                 
                 // 1. Sustain (Dense/Burst) - 3.0s
                 if (ct < 3.0) {
                     rateFactor = 2.5; 
                     if (!stageState._rightFixedRocketsFired) {
                       stageState._rightFixedRocketsFired = true;
                       spawnRocketFixed(13.5, 4.6, 15.2, false, false);
                       spawnRocketFixed(13.5, -4.6, 7.2, false, false);
                     }
                 } 
                 // 2. Interval (Transition) - 1.5s
                 else if (ct < 4.5) {
                     rateFactor = 1.2; 
                 }
                 // 3. Sustain (Extra Dense) - 3.0s
                 else if (ct < 7.5) {
                     rateFactor = 3.0;
                 }
                 // 4. Interval - 1.0s
                 else if (ct < 8.5) {
                     rateFactor = 1.2;
                 }
                 // 5. Final Sustain - Remaining (~0.7s)
                 else {
                     rateFactor = 2.2;
                 }

               } else {
                 // 渐弱阶段 (Symmetric Ramp Down)
                 const downProgress = (ft - rampUp - climax) / rampDown;
                 
                 // Symmetric curve to rampUp: Linear decay from 1.2 to 0.4
                 // rampUp went 0.5 -> 1.2. 
                 // rampDown goes 1.2 -> 0.4.
                 rateFactor = lerp(1.2, 0.4, downProgress);
                 
                 // Audio: Gradually sparse
                 stageState.soundMinGap = lerp(50, 300, downProgress);
                 stageState.soundMaxGap = lerp(150, 600, downProgress);
                 
                 stageState._currentRateFactor = rateFactor; // Store for Sound Logic
               }
               
               stageState._currentRateFactor = rateFactor; // Store for Sound Logic
               
               let spawnRate = CONFIG.fireworks.rocketsPerSecond * rateFactor * 1.2; // 密度增加20%
               
               // Giant Probability Adjustment based on Density Phase
               // If rateFactor > 2.0 (Extra Dense), boost Giant Prob
               // If rateFactor < 0.6 (Sparse), lower Giant Prob
               let giantProb = 0.6; // Default Climax Prob
               
               if (ft < rampUp) giantProb = 0.2; // RampUp Low
               else if (ft >= rampUp + climax) {
                  // RampDown: Linear decay of Giant Prob (Symmetric)
                  const downProgress = (ft - rampUp - climax) / rampDown;
                  giantProb = lerp(0.6, 0.1, downProgress);
               }
               else {
                   // Inside Climax
                   if (rateFactor > 2.0) giantProb = 0.8; // Boost for dense phases
                   else if (rateFactor < 0.8) giantProb = 0.3; // Lower for sparse phases
               }

               // Define rangeScale based on phase to avoid ReferenceError
               let rangeScale = 1.0;
               if (ft < rampUp) rangeScale = 0.7;
               else if (ft < rampUp + climax) rangeScale = 1.3;
               else rangeScale = 0.9;

               stageState._rocketAcc = (stageState._rocketAcc || 0) + dt * spawnRate;

               while (stageState._rocketAcc > 1) {
                 stageState._rocketAcc -= 1;
                 
                 let isGiant = Math.random() < giantProb;

                 // 高潮时50%概率触发巨型烟花二次爆炸
                 const hasSecondary = isGiant && Math.random() < 0.5;
                 spawnRocket(t, rangeScale, isGiant, hasSecondary);
               }
            }
          } else if (stageState.stage === 7) {
            updateSuperGiant(dt, t);
          } else if (stageState.stage === 6) {
            morph.phase = 3;
            morph.useDots = true;
            const k = stageState.stageT;
            const lineDur = 1.5;
            const lineDelay = 1.85;
            const r0 = clamp(k / lineDur, 0, 1);
            const r1 = k < lineDelay ? 0 : clamp((k - lineDelay) / lineDur, 0, 1);
            const r2 = k < lineDelay * 2 ? 0 : clamp((k - lineDelay * 2) / lineDur, 0, 1);
            morph.reveal3.set(r0, r1, r2);
          }
        }

        const rocketState = {
          active: [],
          idx: [],
          color: [],
          apexY: [],
          isGiant: [],
          hasSecondary: [],
          soundTriggered: [],
        };

        const _rocketTmpP = new THREE.Vector3();
        const _rocketTmpNdc = new THREE.Vector3();

        function spawnRocket(t, rangeScale = 1.0, isGiant = false, hasSecondary = false) {
          if (typeof soundManager !== 'undefined') {
             // Stage 4 Normal Fireworks:
             // 1. < 15000 particles: Randomly play launch for approx 3 rockets total.
             // 2. > 15000 particles: Silent (only climax).
             if (stageState.stage === 4 && !isGiant) {
                 const count = stageState._aliveCount || 0;
                 if (count < 15000) {
                     // User Request: "Only 5 launch sounds total"
                     // Strategy: High probability (20%) but with strict time interval (Debounce).
                     // This ensures they DO play (fixing "no sound") but NOT densely (fixing "too dense").
                     const now = Date.now();
                     if (stageState._launchSoundCount < 5 && 
                         (now - (stageState._lastLaunchSoundTime || 0) > 2000) && // Min 2.0s gap
                         Math.random() < 0.2) { // 20% chance if gap met
                         
                         const audio = soundManager.play('launch', { pitch: rand(0.9, 1.1), volume: 0.5, force: true });
                         if (audio) {
                            stageState._launchSoundCount++;
                            stageState._lastLaunchSoundTime = now;
                         }
                     }
                 }
                 // If count >= 15000, do nothing (silent)
             } else if (stageState.stage === 4 && isGiant) {
                 const count = stageState._aliveCount || 0;
                 if (count < 15000) {
                     const now = Date.now();
                     if (stageState._launchSoundCount < 5 && 
                         (now - (stageState._lastLaunchSoundTime || 0) > 2000) &&
                         Math.random() < 0.2) {
                         
                         const audio = soundManager.play('launch', { pitch: rand(0.9, 1.1), volume: 0.5, force: true });
                         if (audio) {
                            stageState._launchSoundCount++;
                            stageState._lastLaunchSoundTime = now;
                         }
                     }
                 }
             } else if (stageState.stage !== 7) {
                // Other stages (1,2,3,4-Giant) always play full volume
                const audio = soundManager.play('launch', { pitch: rand(0.9, 1.1), force: true });
             }
             // Stage 7: Handled manually in updateSuperGiant
          }
          const ux = Math.random() * 2 - 1;
          const uz = Math.random() * 2 - 1;
          // 动态范围控制
          // 改为完全均匀分布 (Power 1.0)，确保覆盖所有空间
          // 并扩大X/Z轴的基础乘数，确保利用整个屏幕宽度
          const bx = Math.sign(ux) * Math.abs(ux); 
          const bz = Math.sign(uz) * Math.abs(uz);
          
          // 范围调整：
          // X: 14.0 (足够宽，覆盖两侧)
          // Z: 9.0 (足够深)
          let x = bx * 14.0 * rangeScale; 
          let z = -2.1 + bz * 9.0 * rangeScale;
          if (stageState.stage === 4) {
            x += (CONFIG.fireworks.biasX || 0) * rangeScale;
            z += (CONFIG.fireworks.biasZ || 0) * rangeScale;
          }
          
          // 移除修正左侧烟花位置的逻辑，因为现在的分布已经足够随机且均匀
          // 保留finalApexYModifier变量以免报错，但设为0
          let finalApexYModifier = 0;
          
          const start = new THREE.Vector3(x, -1.1, z);
          const s = CONFIG.fireworks.speedScale || 1;
          const gEff = (CONFIG.fireworks.gravity || 0) * s * 0.78;
          let targetY = (controls && controls.target ? controls.target.y : 0) || 0;
          if (stageState.stage === 4) {
            if (stageState._spawnTargetY == null) stageState._spawnTargetY = targetY;
            targetY = stageState._spawnTargetY || 0;
          }
          let minApexY = isGiant ? 12.5 : 1.8;
          let maxApexY = isGiant ? 18.5 : 15.0;
          if (stageState.stage === 4 && camera) {
            const dist = controls && controls.target ? camera.position.distanceTo(controls.target) : Math.abs(camera.position.z);
            const fov = (camera.fov * Math.PI) / 180;
            const visibleH = 2 * Math.tan(fov / 2) * dist;
            const bottom = targetY - visibleH * 0.5;
            const low = bottom + visibleH * 0.15;
            const high = bottom + visibleH * 0.85;
            if (isGiant) {
              minApexY = lerp(low, high, 0.76);
              maxApexY = lerp(low, high, 0.98);
            } else {
              minApexY = lerp(low, high, 0.04);
              maxApexY = lerp(low, high, 0.92);
            }
          }
          if (stageState.stage === 4) {
            const by = CONFIG.fireworks.biasY || 0;
            if (by) {
              minApexY += by;
              maxApexY += by;
            }
          }

          if (stageState.stage === 4 && !isGiant) {
            const rf = stageState._currentRateFactor || 0;
            const down =
              rf >= 3.0 ? 3.0 :
              rf >= 2.4 ? 2.4 :
              rf >= 2.0 ? 1.8 :
              rf >= 1.2 ? 0.9 : 0.0;
            if (down > 0) {
              minApexY -= down;
              maxApexY -= down;
            }
          }
          minApexY = Math.max(minApexY, start.y + 0.65);
          maxApexY = Math.max(minApexY + 0.8, maxApexY);
          const uApex = Math.random();
          const bias = isGiant ? Math.pow(uApex, 0.65) : Math.pow(uApex, 1.45);
          let apex = lerp(minApexY, maxApexY, bias) + finalApexYModifier;
          const dy = Math.max(0.1, apex - start.y);
          const vy = Math.sqrt(Math.max(0, 2 * gEff * dy)) * rand(1.02, 1.12);
          const v = new THREE.Vector3(rand(-0.15, 0.15) * s, vy, rand(-0.15, 0.15) * s);
          const c = pickNeonColor();
          // 如果是巨型烟花，使用更长的拖尾(kind=0, 但我们可以稍后在explode时区分)
          // 这里发射阶段还是用普通火箭拖尾
          const tUp = gEff > 1e-6 ? vy / gEff : 2.0;
          const rocketLife = Math.max(4.8, tUp * 1.65 + 1.25);
          const idx = particles.spawnParticle(start, v, c, rocketLife, 0);
          if (!stageState._firstRocketLogged) {
            stageState._firstRocketLogged = true;
            DEBUG.log("rocket spawn", { idx, start: { x: start.x, y: start.y, z: start.z } });
          }
          rocketState.active.push(1);
          rocketState.idx.push(idx);
          rocketState.color.push(c);
          rocketState.isGiant.push(isGiant);
          rocketState.hasSecondary.push(hasSecondary);
          rocketState.soundTriggered.push(false);
          rocketState.apexY.push(apex);
        }

        function spawnRocketFixed(x, z, apexY, isGiant = false, hasSecondary = false) {
          if (typeof soundManager !== 'undefined' && stageState.stage !== 7) {
             // Respect Stage 4 logic
             if (stageState.stage === 4) {
                 const count = stageState._aliveCount || 0;
                 if (count < 15000) {
                     const now = Date.now();
                     if (stageState._launchSoundCount < 5 && 
                         (now - (stageState._lastLaunchSoundTime || 0) > 2000) &&
                         Math.random() < 0.2) {
                         const audio = soundManager.play('launch', { pitch: rand(0.9, 1.1), volume: 0.5, force: true });
                         if (audio) {
                            stageState._launchSoundCount++;
                            stageState._lastLaunchSoundTime = now;
                         }
                     }
                 }
             } else {
                 soundManager.play('launch', { pitch: rand(0.9, 1.1), force: true });
             }
          }
          const start = new THREE.Vector3(x, -1.1, z);
          const s = CONFIG.fireworks.speedScale || 1;
          const gEff = (CONFIG.fireworks.gravity || 0) * s * 0.78;
          const dy = Math.max(0.1, apexY - start.y);
          const vy = Math.sqrt(Math.max(0, 2 * gEff * dy)) * rand(1.03, 1.11);
          const v = new THREE.Vector3(rand(-0.12, 0.18) * s, vy, rand(-0.15, 0.15) * s);
          const c = pickNeonColor();
          const tUp = gEff > 1e-6 ? vy / gEff : 2.0;
          const rocketLife = Math.max(4.8, tUp * 1.65 + 1.25);
          const idx = particles.spawnParticle(start, v, c, rocketLife, 0);
          rocketState.active.push(1);
          rocketState.idx.push(idx);
          rocketState.color.push(c);
          rocketState.isGiant.push(isGiant);
          rocketState.hasSecondary.push(hasSecondary);
          rocketState.soundTriggered.push(false);
          rocketState.apexY.push(apexY);
        }

        function updateRockets(dt, t) {
          const s = CONFIG.fireworks.speedScale || 1;
          const g = CONFIG.fireworks.gravity * s;
          const turnVy = 0.18 * s;
          // 相应扩大safe范围，避免烟花过早消失
          const safe = { x: 20.0, y: 40.0, z0: -16.0, z1: 12.0 };
          for (let i = rocketState.idx.length - 1; i >= 0; i--) {
            const idx = rocketState.idx[i];
            if (!particles.alive[idx] || particles.kind[idx] !== 0) {
              rocketState.active.splice(i, 1);
              rocketState.idx.splice(i, 1);
              rocketState.color.splice(i, 1);
              rocketState.apexY.splice(i, 1);
              rocketState.isGiant.splice(i, 1);
              rocketState.hasSecondary.splice(i, 1);
              rocketState.soundTriggered.splice(i, 1);
              continue;
            }
            const b = idx * 3;
            const y = particles.pos[b + 1];
            const vy = particles.vel[b + 1];
            const x = particles.pos[b + 0];
            const z = particles.pos[b + 2];
            const out = Math.abs(x) > safe.x || y > safe.y || z < safe.z0 || z > safe.z1;
            const nextVy = vy * 0.998 - g * dt * 0.78;
            const age = particles.age[idx];
            const life = particles.life[idx];
            const ageNext = age + dt;
            const willDie = life > 0 ? ageNext >= life * 0.995 : false;
            const nearEnd = life > 0 ? ageNext >= life * 0.88 : false;

            let screenOut = false;
            if (stageState.stage === 4 && camera) {
              camera.updateMatrixWorld(true);
              _rocketTmpP.set(x, y, z);
              _rocketTmpNdc.copy(_rocketTmpP).project(camera);
              const margin = 0.92;
              const nowOver =
                Math.abs(_rocketTmpNdc.x) > margin ||
                Math.abs(_rocketTmpNdc.y) > margin ||
                _rocketTmpNdc.z < -1 ||
                _rocketTmpNdc.z > 1;
              const nx = x + particles.vel[b + 0] * dt;
              const ny = y + vy * dt;
              const nz = z + particles.vel[b + 2] * dt;
              _rocketTmpP.set(nx, ny, nz);
              _rocketTmpNdc.copy(_rocketTmpP).project(camera);
              const nextOver =
                Math.abs(_rocketTmpNdc.x) > margin ||
                Math.abs(_rocketTmpNdc.y) > margin ||
                _rocketTmpNdc.z < -1 ||
                _rocketTmpNdc.z > 1;
              screenOut = nowOver || nextOver;
            }

            if (out || screenOut || willDie || y >= rocketState.apexY[i] || vy <= 0 || nextVy <= turnVy || nearEnd) {
              const p = new THREE.Vector3(particles.pos[b + 0], particles.pos[b + 1], particles.pos[b + 2]);

               // Pass playSound=!soundTriggered to prevent double playing
              explodeAt(
                p,
                rocketState.color[i],
                rand(6.3, 10.4),
                undefined,
                rocketState.isGiant[i],
                rocketState.hasSecondary[i],
                !rocketState.soundTriggered[i],
                false
              );
              // Instead of killing, switch to dying state (kind=5) to let trail fade out
               particles.kind[idx] = 5;
               // Store current alpha for smooth fading
               const baseIdx = idx;
               let currentAlpha = 0.88;
               // Calculate current alpha based on age/life to match exactly
               if (particles.life[idx] > 0) {
                 const a = 1.0 - particles.age[idx] / particles.life[idx];
                 currentAlpha = Math.pow(a, 1.75) * 0.88;
               }
               particles.iDelay[idx] = currentAlpha; // Store as base alpha
               
               particles.age[idx] = 0;
               particles.life[idx] = 1.05; // Match trail life
               particles.iGroup[idx] = 0;
               // Kill velocity to freeze in place
               particles.vel[b + 0] = 0;
               particles.vel[b + 1] = 0;
               particles.vel[b + 2] = 0;
 
               rocketState.active.splice(i, 1);
              rocketState.idx.splice(i, 1);
              rocketState.color.splice(i, 1);
              rocketState.apexY.splice(i, 1);
              rocketState.isGiant.splice(i, 1);
              rocketState.hasSecondary.splice(i, 1);
              rocketState.soundTriggered.splice(i, 1);
            }
          }
        }

        function updateCameraAuto(dt, t) {
          // 仅在烟花阶段自动控制相机，文字阶段(Stage 5)交由用户控制
          // 但在Stage 5初期（小马奔跑阶段），相机应逐渐减速而不是突然停止
          
          const targetShiftGoalX = stageState.stage === 4 ? 2.1 : 0.0;
          if (stageState._centerShiftX == null) stageState._centerShiftX = 0.0;
          stageState._centerShiftX = lerp(stageState._centerShiftX, targetShiftGoalX, 1 - Math.pow(0.0008, dt));

          if (stageState.stage === 4) {
            controls.enablePan = false;
            controls.enableZoom = true;
            controls.enableRotate = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.69;
            controls.minPolarAngle = 0.0;
            controls.maxPolarAngle = Math.PI - 0.2;

            const _tmpTarget = updateCameraAuto._tmpTarget || (updateCameraAuto._tmpTarget = new THREE.Vector3());
            _tmpTarget.set(stageState._centerShiftX || 0, 2.0, 0);
            const lerpK = 1 - Math.pow(0.0009, dt);

            const enterPos = stageState._camEnterPos;
            const enterTarget = stageState._camEnterTarget;
            const dur = stageState._camEnterDur || 0;

            if (enterPos && enterTarget && dur > 0 && stageState.stageT < dur) {
              const r = 25.0;
              const offset = stageState.camOffsetAngle || 0;
              const a = t * 0.072 + offset;
              const y = -2.0;
              const _tmpPos = updateCameraAuto._tmpPos || (updateCameraAuto._tmpPos = new THREE.Vector3());
              _tmpPos.set(Math.cos(a) * r, y, Math.sin(a) * r);
              const k = clamp(stageState.stageT / dur, 0, 1);
              const kk = k * k * (3 - 2 * k);
              camera.position.lerpVectors(enterPos, _tmpPos, kk);
              controls.target.lerpVectors(enterTarget, _tmpTarget, kk);
            } else if (enterPos || enterTarget) {
              stageState._camEnterPos = null;
              stageState._camEnterTarget = null;
              stageState._camEnterDur = 0;
              controls.target.lerp(_tmpTarget, lerpK);
            } else {
              controls.target.lerp(_tmpTarget, lerpK);
            }
          } else if (stageState.stage < 4) {
            // 其他阶段(Stage 1-3)恢复默认视角限制 (约74度)
            if (controls.maxPolarAngle !== 1.3) controls.maxPolarAngle = 1.3;
            if (controls.autoRotate) controls.autoRotate = false;
            if (controls.minPolarAngle !== 0.45) controls.minPolarAngle = 0.45;
            if (stageState._spawnTargetY != null) stageState._spawnTargetY = null;
          }
          // Stage 5 & 6 handle their own camera settings
        }

        function resize() {
          const w = window.innerWidth;
          const h = window.innerHeight;
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          const deviceDpr = window.devicePixelRatio || 1;
          const maxDpr = Math.min(CONFIG.visuals.dprMax, deviceDpr);
          const dpr = stageState && stageState._dpr != null ? Math.min(maxDpr, stageState._dpr) : maxDpr;
          renderer.setPixelRatio(dpr);
          renderer.setSize(w, h, false);
          composer.setSize(w, h);
          bloomPass.setSize(w, h);
        }
        window.addEventListener("resize", resize, { passive: true });

        function onPointerDown() {
          if (!stageState.clickArmed) return;
          stageState.clickArmed = false;
          startStage2();
          const hint = document.querySelector(".hint");
          if (hint) hint.style.display = "none";
        }
        window.addEventListener("pointerdown", onPointerDown, { passive: true });
        if (CONFIG.debug.autoStart) {
          setTimeout(() => {
            try {
              onPointerDown();
            } catch (e) {
              DEBUG.error("autostart failed", e);
            }
          }, 650);
        }

        function tick() {
          try {
            if (!composer || !renderer) return;

            if (stageState.paused) {
               // Keep clock running to avoid jump on resume, or consume delta
               clock.getDelta(); 
               requestAnimationFrame(tick);
               return;
            }

            const dt = Math.min(0.033, clock.getDelta());
            const t = clock.elapsedTime;

            updateStages(dt, t);
            updateWords(dt, stageState.stage, t);
            updateMorphBillboard(); // 实时更新广告牌矩阵，确保文字始终正对观众
            updateMorph(dt, t);
            updateCameraAuto(dt, t);
            controls.update();
            stageState.userZoomDist = camera.position.distanceTo(controls.target);
            updateRockets(dt, t);
            
            let aliveCount = 0;
            if (particles && particles.update) {
              aliveCount = particles.update(dt, t, stageState.stage);
            }
            
            stageState._aliveCount = aliveCount;
            if (typeof soundManager !== 'undefined') {
               soundManager.update(dt, aliveCount);
            }
            if (aliveCount > 0) stageState._lastParticlesAt = t;

            if (stageState.stage >= 3) {
              const lastAt = stageState._lastParticlesAt || 0;
              if (t - lastAt > 2.2 && stageState.stage <= 4) {
                stageState._lastParticlesAt = t;
                if (stageState.stage < 4) {
                  stageState.stage = 4;
                  stageState.stageT = 0;
                  stageState.fireworksT = 0;
                }
                spawnRocket(t);
              }
            }
            if (starfield && starfield.group) {
              starfield.group.rotation.y += dt * 0.03;
              starfield.group.rotation.x += dt * 0.012;
            }

            stageState._fpsAcc = (stageState._fpsAcc || 0) + dt;
            stageState._fpsFrames = (stageState._fpsFrames || 0) + 1;
            if (stageState._fpsAcc > 0.5) {
              stageState._fps = Math.round(stageState._fpsFrames / stageState._fpsAcc);
              stageState._fpsAcc = 0;
              stageState._fpsFrames = 0;
              const deviceDpr = window.devicePixelRatio || 1;
              const maxDpr = Math.min(CONFIG.visuals.dprMax, deviceDpr);
              if (stageState._dpr == null) stageState._dpr = maxDpr;
              let nextDpr = stageState._dpr;
              const fpsNow = stageState._fps || 0;
              if (fpsNow > 0 && fpsNow < 52) nextDpr = Math.max(1.0, nextDpr - 0.15);
              if (fpsNow >= 58) nextDpr = Math.min(maxDpr, nextDpr + 0.1);
              if (Math.abs(nextDpr - stageState._dpr) > 1e-6) {
                stageState._dpr = nextDpr;
                const w = window.innerWidth;
                const h = window.innerHeight;
                renderer.setPixelRatio(nextDpr);
                renderer.setSize(w, h, false);
                composer.setSize(w, h);
                bloomPass.setSize(w, h);
              }
            }

            if (DEBUG.enabled && DEBUG.overlay) {
              if (!DEBUG.lastOverlayAt || t - DEBUG.lastOverlayAt > 0.12) {
                DEBUG.lastOverlayAt = t;
                DEBUG.overlayText(`particles: ${aliveCount}\nfps: ${stageState._fps || 0}`);
              }
            }

            // Ensure updateMorphBillboard is called
            updateMorphBillboard();
            if (composer && typeof composer.render === 'function') {
              composer.render();
            } else {
              renderer.render(scene, camera);
            }
          } catch (e) {
            DEBUG.setError(e && e.message ? e.message : e);
            DEBUG.error("tick crash", e);
          }
          requestAnimationFrame(tick);
        }
        tick();
      })();
    </script>
  </body>
</html>

